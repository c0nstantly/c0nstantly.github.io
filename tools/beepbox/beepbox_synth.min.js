var beepbox=function(t){"use strict";
/*!
    Copyright (C) 2021 John Nesky

    Permission is hereby granted, free of charge, to any person obtaining a copy of
    this software and associated documentation files (the "Software"), to deal in
    the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
    of the Software, and to permit persons to whom the Software is furnished to do
    so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
    */class e{}function s(t){let e=0;for(let s=0;s<t.length;s++)e+=t[s];const s=e/t.length;for(let e=0;e<t.length;e++)t[e]-=s;return n(t),t.push(0),new Float64Array(t)}function n(t){let e=0;for(let s=0;s<t.length;s++){const n=t[s];t[s]=e,e+=n}}function i(t){return.5*Math.pow(.5,(e.pulseWidthRange-1-t)*e.pulseWidthStepPower)}function a(t,s,n){let i=e.chipNoises[t].samples;if(null==i){if(i=new Float32Array(e.chipNoiseLength+1),e.chipNoises[t].samples=i,0==t){let t=1;for(let s=0;s<e.chipNoiseLength;s++){i[s]=2*(1&t)-1;let e=t>>1;1==(t+e&1)&&(e+=16384),t=e}}else if(1==t)for(let t=0;t<e.chipNoiseLength;t++)i[t]=2*Math.random()-1;else if(2==t){let t=1;for(let s=0;s<e.chipNoiseLength;s++){i[s]=2*(1&t)-1;let e=t>>1;1==(t+e&1)&&(e+=32768),t=e}}else if(3==t){let t=1;for(let s=0;s<e.chipNoiseLength;s++){i[s]=2*(1&t)-1;let e=t>>1;1==(t+e&1)&&(e+=40),t=e}}else{if(4!=t)throw new Error("Unrecognized drum index: "+t);r(i,e.chipNoiseLength,10,11,1,1,0),r(i,e.chipNoiseLength,11,14,.6578,.6578,0),s(i,e.chipNoiseLength),n(i,1/Math.sqrt(e.chipNoiseLength))}i[e.chipNoiseLength]=i[0]}return i}function r(t,e,s,n,i,r,h){const o=0|Math.pow(2,s),l=Math.min(e>>1,0|Math.pow(2,n)),c=a(0,null,null);let u=0;for(let a=o;a<l;a++){let o=i+(r-i)*(Math.log2(a)-s)/(n-s),l=Math.pow(2,7*(o-1)+1)*o;l*=Math.pow(a/2048,h),u+=l,l*=c[a];const f=.61803398875*a*a*Math.PI*2;t[a]=Math.cos(f)*l,t[e-a]=Math.sin(f)*l}return u}function h(t,s,n){const i=e.rhythms[s].arpeggioPatterns[t-1];return null!=i?i[n%i.length]:n%t}function o(t){const e={};for(let s=0;s<t.length;s++){const n=t[s];n.index=s,e[n.name]=n}const s=t;return s.dictionary=e,s}function l(t){return 0!=(1024&t)}function c(t){return 0!=(2048&t)}function u(t){return 0!=(128&t)}function f(t){return 0!=(256&t)}function p(t){return 0!=(512&t)}function d(t){return 0!=(32&t)}function m(t){return 0!=(8&t)}function S(t){return 0!=(16&t)}function y(t){return 0!=(4&t)}function b(t){return 0!=(2&t)}function M(t){return 0!=(64&t)}function g(t){return 0!=(1&t)}function v(t,e){for(let s=0;s<t.length;s++)t[s]*=e}function I(t){if(!function(t){return!(!t||t&t-1)}(t))throw new Error("FFT array length must be a power of 2.");return Math.round(Math.log(t)/Math.log(2))}function P(t,e){const s=I(e);if(e<4)throw new Error("FFT array length must be at least 4.");for(let n=s-1;n>=2;n--){const s=1<<n,i=s>>1,a=s<<1,r=2*Math.PI/a,h=Math.cos(r),o=Math.sin(r),l=2*h;for(let n=0;n<e;n+=a){const e=n,a=e+i,r=e+s,c=r+i,u=r+s,f=t[e],p=t[r];t[e]=f+p,t[a]*=2,t[r]=f-p,t[c]*=2;let d=h,m=-o,S=1,y=0;for(let s=1;s<i;s++){const n=e+s,i=r-s,a=r+s,h=u-s,o=t[n],c=t[i],f=t[a],p=t[h],b=o-c,M=f+p;t[n]=o+c,t[i]=p-f,t[a]=b*d-M*m,t[h]=M*d+b*m;const g=l*d-S,v=l*m-y;S=d,y=m,d=g,m=v}}}for(let s=0;s<e;s+=4){const e=s+1,n=s+2,i=s+3,a=t[s],r=2*t[e],h=t[n],o=2*t[i],l=a+h,c=a-h;t[s]=l+r,t[e]=l-r,t[n]=c+o,t[i]=c-o}!function(t,e){const s=I(e);if(s>16)throw new Error("FFT array length must not be greater than 2^16.");const n=16-s;for(let s=0;s<e;s++){let e;if(e=(43690&s)>>1|(21845&s)<<1,e=(52428&e)>>2|(13107&e)<<2,e=(61680&e)>>4|(3855&e)<<4,e=(e>>8|(255&e)<<8)>>n,e>s){let n=t[s];t[s]=t[e],t[e]=n}}}(t,e)}e.scales=o([{name:"easy :)",realName:"pentatonic major",flags:[!0,!1,!0,!1,!0,!1,!1,!0,!1,!0,!1,!1]},{name:"easy :(",realName:"pentatonic minor",flags:[!0,!1,!1,!0,!1,!0,!1,!0,!1,!1,!0,!1]},{name:"island :)",realName:"ryukyu",flags:[!0,!1,!1,!1,!0,!0,!1,!0,!1,!1,!1,!0]},{name:"island :(",realName:"pelog selisir",flags:[!0,!0,!1,!0,!1,!1,!1,!0,!0,!1,!1,!1]},{name:"blues :)",realName:"blues major",flags:[!0,!1,!0,!0,!0,!1,!1,!0,!1,!0,!1,!1]},{name:"blues :(",realName:"blues",flags:[!0,!1,!1,!0,!1,!0,!0,!0,!1,!1,!0,!1]},{name:"normal :)",realName:"ionian",flags:[!0,!1,!0,!1,!0,!0,!1,!0,!1,!0,!1,!0]},{name:"normal :(",realName:"aeolian",flags:[!0,!1,!0,!0,!1,!0,!1,!0,!0,!1,!0,!1]},{name:"dbl harmonic :)",realName:"double harmonic major",flags:[!0,!0,!1,!1,!0,!0,!1,!0,!0,!1,!1,!0]},{name:"dbl harmonic :(",realName:"double harmonic minor",flags:[!0,!1,!0,!0,!1,!1,!0,!0,!0,!1,!1,!0]},{name:"strange",realName:"whole tone",flags:[!0,!1,!0,!1,!0,!1,!0,!1,!0,!1,!0,!1]},{name:"expert",realName:"chromatic",flags:[!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0]}]),e.keys=o([{name:"C",isWhiteKey:!0,basePitch:12},{name:"C♯",isWhiteKey:!1,basePitch:13},{name:"D",isWhiteKey:!0,basePitch:14},{name:"D♯",isWhiteKey:!1,basePitch:15},{name:"E",isWhiteKey:!0,basePitch:16},{name:"F",isWhiteKey:!0,basePitch:17},{name:"F♯",isWhiteKey:!1,basePitch:18},{name:"G",isWhiteKey:!0,basePitch:19},{name:"G♯",isWhiteKey:!1,basePitch:20},{name:"A",isWhiteKey:!0,basePitch:21},{name:"A♯",isWhiteKey:!1,basePitch:22},{name:"B",isWhiteKey:!0,basePitch:23}]),e.blackKeyNameParents=[-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1],e.tempoMin=30,e.tempoMax=300,e.echoDelayRange=24,e.echoDelayStepTicks=4,e.echoSustainRange=8,e.echoShelfHz=4e3,e.echoShelfGain=Math.pow(2,-.5),e.reverbShelfHz=8e3,e.reverbShelfGain=Math.pow(2,-1.5),e.reverbRange=4,e.reverbDelayBufferSize=16384,e.reverbDelayBufferMask=e.reverbDelayBufferSize-1,e.beatsPerBarMin=3,e.beatsPerBarMax=16,e.barCountMin=1,e.barCountMax=128,e.instrumentCountMin=1,e.layeredInstrumentCountMax=4,e.patternInstrumentCountMax=10,e.partsPerBeat=24,e.ticksPerPart=2,e.rhythms=o([{name:"÷3 (triplets)",stepsPerBeat:3,ticksPerArpeggio:4,arpeggioPatterns:[[0],[0,0,1,1],[0,1,2,1]],roundUpThresholds:[5,12,18]},{name:"÷4 (standard)",stepsPerBeat:4,ticksPerArpeggio:3,arpeggioPatterns:[[0],[0,0,1,1],[0,1,2,1]],roundUpThresholds:[3,9,17,21]},{name:"÷6",stepsPerBeat:6,ticksPerArpeggio:4,arpeggioPatterns:[[0],[0,1],[0,1,2,1]],roundUpThresholds:null},{name:"÷8",stepsPerBeat:8,ticksPerArpeggio:3,arpeggioPatterns:[[0],[0,1],[0,1,2,1]],roundUpThresholds:null},{name:"freehand",stepsPerBeat:24,ticksPerArpeggio:3,arpeggioPatterns:[[0],[0,1],[0,1,2,1]],roundUpThresholds:null}]),e.instrumentTypeNames=["chip","FM","noise","spectrum","drumset","harmonics","PWM","Picked String"],e.instrumentTypeHasSpecialInterval=[!0,!0,!1,!1,!1,!0,!1,!1],e.chipBaseExpression=.03375,e.fmBaseExpression=.03,e.noiseBaseExpression=.19,e.spectrumBaseExpression=.3,e.drumsetBaseExpression=.45,e.harmonicsBaseExpression=.025,e.pwmBaseExpression=.04725,e.pickedStringBaseExpression=.025,e.distortionBaseVolume=.011,e.bitcrusherBaseVolume=.01,e.chipWaves=o([{name:"rounded",expression:.94,samples:s([0,.2,.4,.5,.6,.7,.8,.85,.9,.95,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.95,.9,.85,.8,.7,.6,.5,.4,.2,0,-.2,-.4,-.5,-.6,-.7,-.8,-.85,-.9,-.95,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-.95,-.9,-.85,-.8,-.7,-.6,-.5,-.4,-.2])},{name:"triangle",expression:1,samples:s([1/15,.2,5/15,7/15,.6,11/15,13/15,1,1,13/15,11/15,.6,7/15,5/15,.2,1/15,-1/15,-.2,-5/15,-7/15,-.6,-11/15,-13/15,-1,-1,-13/15,-11/15,-.6,-7/15,-5/15,-.2,-1/15])},{name:"square",expression:.5,samples:s([1,-1])},{name:"1/4 pulse",expression:.5,samples:s([1,-1,-1,-1])},{name:"1/8 pulse",expression:.5,samples:s([1,-1,-1,-1,-1,-1,-1,-1])},{name:"sawtooth",expression:.65,samples:s([1/31,3/31,5/31,7/31,9/31,11/31,13/31,15/31,17/31,19/31,21/31,23/31,25/31,27/31,29/31,1,-1,-29/31,-27/31,-25/31,-23/31,-21/31,-19/31,-17/31,-15/31,-13/31,-11/31,-9/31,-7/31,-5/31,-3/31,-1/31])},{name:"double saw",expression:.5,samples:s([0,-.2,-.4,-.6,-.8,-1,1,-.8,-.6,-.4,-.2,1,.8,.6,.4,.2])},{name:"double pulse",expression:.4,samples:s([1,1,1,1,1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1])},{name:"spiky",expression:.4,samples:s([1,-1,1,-1,1,0])}]),e.chipNoises=o([{name:"retro",expression:.25,basePitch:69,pitchFilterMult:1024,isSoft:!1,samples:null},{name:"white",expression:1,basePitch:69,pitchFilterMult:8,isSoft:!0,samples:null},{name:"clang",expression:.4,basePitch:69,pitchFilterMult:1024,isSoft:!1,samples:null},{name:"buzz",expression:.3,basePitch:69,pitchFilterMult:1024,isSoft:!1,samples:null},{name:"hollow",expression:1.5,basePitch:96,pitchFilterMult:1,isSoft:!0,samples:null}]),e.filterFreqStep=1/4,e.filterFreqRange=34,e.filterFreqReferenceSetting=28,e.filterFreqReferenceHz=8e3,e.filterFreqMaxHz=e.filterFreqReferenceHz*Math.pow(2,e.filterFreqStep*(e.filterFreqRange-1-e.filterFreqReferenceSetting)),e.filterFreqMinHz=8,e.filterGainRange=15,e.filterGainCenter=7,e.filterGainStep=.5,e.filterMaxPoints=8,e.filterTypeNames=["low-pass","high-pass","peak"],e.fadeInRange=10,e.fadeOutTicks=[-24,-12,-6,-3,-1,6,12,24,48,72,96],e.fadeOutNeutral=4,e.drumsetFadeOutTicks=48,e.transitions=o([{name:"normal",isSeamless:!1,continues:!1,slides:!1,slideTicks:3,includeAdjacentPatterns:!1},{name:"interrupt",isSeamless:!0,continues:!1,slides:!1,slideTicks:3,includeAdjacentPatterns:!0},{name:"continue",isSeamless:!0,continues:!0,slides:!1,slideTicks:3,includeAdjacentPatterns:!0},{name:"slide",isSeamless:!0,continues:!1,slides:!0,slideTicks:3,includeAdjacentPatterns:!0},{name:"slide in pattern",isSeamless:!0,continues:!1,slides:!0,slideTicks:3,includeAdjacentPatterns:!1}]),e.vibratos=o([{name:"none",amplitude:0,periodsSeconds:[.14],delayTicks:0},{name:"light",amplitude:.15,periodsSeconds:[.14],delayTicks:0},{name:"delayed",amplitude:.3,periodsSeconds:[.14],delayTicks:37},{name:"heavy",amplitude:.45,periodsSeconds:[.14],delayTicks:0},{name:"shaky",amplitude:.1,periodsSeconds:[.11,.17798,.33],delayTicks:0}]),e.unisons=o([{name:"none",voices:1,spread:0,offset:0,expression:1.4,sign:1},{name:"shimmer",voices:2,spread:.018,offset:0,expression:.8,sign:1},{name:"hum",voices:2,spread:.045,offset:0,expression:1,sign:1},{name:"honky tonk",voices:2,spread:.09,offset:0,expression:1,sign:1},{name:"dissonant",voices:2,spread:.25,offset:0,expression:.9,sign:1},{name:"fifth",voices:2,spread:3.5,offset:3.5,expression:.9,sign:1},{name:"octave",voices:2,spread:6,offset:6,expression:.8,sign:1},{name:"bowed",voices:2,spread:.02,offset:0,expression:1,sign:-1},{name:"piano",voices:2,spread:.01,offset:0,expression:1,sign:.7}]),e.effectNames=["reverb","chorus","panning","distortion","bitcrusher","note filter","echo","pitch shift","detune","vibrato","transition type","chord type"],e.effectOrder=[10,11,7,8,9,5,3,4,2,1,6,0],e.noteSizeMax=3,e.volumeRange=8,e.volumeLogScale=-.5,e.panCenter=4,e.panMax=2*e.panCenter,e.panDelaySecondsMax=5e-4,e.chorusRange=4,e.chorusPeriodSeconds=2,e.chorusDelayRange=.0034,e.chorusDelayOffsets=[[1.51,2.1,3.35],[1.47,2.15,3.25]],e.chorusPhaseOffsets=[[0,2.1,4.2],[3.2,5.3,1]],e.chorusMaxDelay=e.chorusDelayRange*(1+e.chorusDelayOffsets[0].concat(e.chorusDelayOffsets[1]).reduce(((t,e)=>Math.max(t,e)))),e.chords=o([{name:"simultaneous",customInterval:!1,arpeggiates:!1,strumParts:0,singleTone:!1},{name:"strum",customInterval:!1,arpeggiates:!1,strumParts:1,singleTone:!1},{name:"arpeggio",customInterval:!1,arpeggiates:!0,strumParts:0,singleTone:!0},{name:"custom interval",customInterval:!0,arpeggiates:!1,strumParts:0,singleTone:!0}]),e.maxChordSize=4,e.operatorCount=4,e.algorithms=o([{name:"1←(2 3 4)",carrierCount:1,associatedCarrier:[1,1,1,1],modulatedBy:[[2,3,4],[],[],[]]},{name:"1←(2 3←4)",carrierCount:1,associatedCarrier:[1,1,1,1],modulatedBy:[[2,3],[],[4],[]]},{name:"1←2←(3 4)",carrierCount:1,associatedCarrier:[1,1,1,1],modulatedBy:[[2],[3,4],[],[]]},{name:"1←(2 3)←4",carrierCount:1,associatedCarrier:[1,1,1,1],modulatedBy:[[2,3],[4],[4],[]]},{name:"1←2←3←4",carrierCount:1,associatedCarrier:[1,1,1,1],modulatedBy:[[2],[3],[4],[]]},{name:"1←3 2←4",carrierCount:2,associatedCarrier:[1,2,1,2],modulatedBy:[[3],[4],[],[]]},{name:"1 2←(3 4)",carrierCount:2,associatedCarrier:[1,2,2,2],modulatedBy:[[],[3,4],[],[]]},{name:"1 2←3←4",carrierCount:2,associatedCarrier:[1,2,2,2],modulatedBy:[[],[3],[4],[]]},{name:"(1 2)←3←4",carrierCount:2,associatedCarrier:[1,2,2,2],modulatedBy:[[3],[3],[4],[]]},{name:"(1 2)←(3 4)",carrierCount:2,associatedCarrier:[1,2,2,2],modulatedBy:[[3,4],[3,4],[],[]]},{name:"1 2 3←4",carrierCount:3,associatedCarrier:[1,2,3,3],modulatedBy:[[],[],[4],[]]},{name:"(1 2 3)←4",carrierCount:3,associatedCarrier:[1,2,3,3],modulatedBy:[[4],[4],[4],[]]},{name:"1 2 3 4",carrierCount:4,associatedCarrier:[1,2,3,4],modulatedBy:[[],[],[],[]]}]),e.operatorCarrierInterval=[0,.04,-.073,.091],e.operatorAmplitudeMax=15,e.operatorFrequencies=o([{name:"1×",mult:1,hzOffset:0,amplitudeSign:1},{name:"~1×",mult:1,hzOffset:1.5,amplitudeSign:-1},{name:"2×",mult:2,hzOffset:0,amplitudeSign:1},{name:"~2×",mult:2,hzOffset:-1.3,amplitudeSign:-1},{name:"3×",mult:3,hzOffset:0,amplitudeSign:1},{name:"4×",mult:4,hzOffset:0,amplitudeSign:1},{name:"5×",mult:5,hzOffset:0,amplitudeSign:1},{name:"6×",mult:6,hzOffset:0,amplitudeSign:1},{name:"7×",mult:7,hzOffset:0,amplitudeSign:1},{name:"8×",mult:8,hzOffset:0,amplitudeSign:1},{name:"9×",mult:9,hzOffset:0,amplitudeSign:1},{name:"11×",mult:11,hzOffset:0,amplitudeSign:1},{name:"13×",mult:13,hzOffset:0,amplitudeSign:1},{name:"16×",mult:16,hzOffset:0,amplitudeSign:1},{name:"20×",mult:20,hzOffset:0,amplitudeSign:1}]),e.envelopes=o([{name:"none",type:1,speed:0},{name:"note size",type:0,speed:0},{name:"punch",type:2,speed:0},{name:"flare 1",type:3,speed:32},{name:"flare 2",type:3,speed:8},{name:"flare 3",type:3,speed:2},{name:"twang 1",type:4,speed:32},{name:"twang 2",type:4,speed:8},{name:"twang 3",type:4,speed:2},{name:"swell 1",type:5,speed:32},{name:"swell 2",type:5,speed:8},{name:"swell 3",type:5,speed:2},{name:"tremolo1",type:6,speed:4},{name:"tremolo2",type:6,speed:2},{name:"tremolo3",type:6,speed:1},{name:"tremolo4",type:7,speed:4},{name:"tremolo5",type:7,speed:2},{name:"tremolo6",type:7,speed:1},{name:"decay 1",type:8,speed:10},{name:"decay 2",type:8,speed:7},{name:"decay 3",type:8,speed:4}]),e.feedbacks=o([{name:"1⟲",indices:[[1],[],[],[]]},{name:"2⟲",indices:[[],[2],[],[]]},{name:"3⟲",indices:[[],[],[3],[]]},{name:"4⟲",indices:[[],[],[],[4]]},{name:"1⟲ 2⟲",indices:[[1],[2],[],[]]},{name:"3⟲ 4⟲",indices:[[],[],[3],[4]]},{name:"1⟲ 2⟲ 3⟲",indices:[[1],[2],[3],[]]},{name:"2⟲ 3⟲ 4⟲",indices:[[],[2],[3],[4]]},{name:"1⟲ 2⟲ 3⟲ 4⟲",indices:[[1],[2],[3],[4]]},{name:"1→2",indices:[[],[1],[],[]]},{name:"1→3",indices:[[],[],[1],[]]},{name:"1→4",indices:[[],[],[],[1]]},{name:"2→3",indices:[[],[],[2],[]]},{name:"2→4",indices:[[],[],[],[2]]},{name:"3→4",indices:[[],[],[],[3]]},{name:"1→3 2→4",indices:[[],[],[1],[2]]},{name:"1→4 2→3",indices:[[],[],[2],[1]]},{name:"1→2→3→4",indices:[[],[1],[2],[3]]}]),e.chipNoiseLength=32768,e.spectrumNoiseLength=32768,e.spectrumBasePitch=24,e.spectrumControlPoints=30,e.spectrumControlPointsPerOctave=7,e.spectrumControlPointBits=3,e.spectrumMax=(1<<e.spectrumControlPointBits)-1,e.harmonicsControlPoints=28,e.harmonicsRendered=64,e.harmonicsRenderedForPickedString=256,e.harmonicsControlPointBits=3,e.harmonicsMax=(1<<e.harmonicsControlPointBits)-1,e.harmonicsWavelength=2048,e.pulseWidthRange=8,e.pulseWidthStepPower=.5,e.pitchChannelCountMin=1,e.pitchChannelCountMax=10,e.noiseChannelCountMin=0,e.noiseChannelCountMax=5,e.noiseInterval=6,e.pitchesPerOctave=12,e.drumCount=12,e.pitchOctaves=7,e.maxPitch=e.pitchOctaves*e.pitchesPerOctave,e.maximumTonesPerChannel=2*e.maxChordSize,e.justIntonationSemitones=[.5,8/15,9/16,.6,5/8,2/3,32/45,3/4,.8,5/6,8/9,15/16,1,16/15,9/8,1.2,5/4,4/3,45/32,1.5,1.6,5/3,16/9,15/8,2].map((t=>Math.log2(t)*e.pitchesPerOctave)),e.pitchShiftRange=e.justIntonationSemitones.length,e.pitchShiftCenter=e.pitchShiftRange>>1,e.detuneCenter=9,e.detuneMax=2*e.detuneCenter,e.sineWaveLength=256,e.sineWaveMask=e.sineWaveLength-1,e.sineWave=function(){const t=new Float64Array(e.sineWaveLength+1);for(let s=0;s<e.sineWaveLength+1;s++)t[s]=Math.sin(s*Math.PI*2/e.sineWaveLength);return t}(),e.pickedStringDispersionCenterFreq=6e3,e.pickedStringDispersionFreqScale=.3,e.pickedStringDispersionFreqMult=4,e.pickedStringShelfHz=4e3,e.distortionRange=8,e.stringSustainRange=15,e.stringDecayRate=.12,e.bitcrusherFreqRange=14,e.bitcrusherOctaveStep=.5,e.bitcrusherQuantizationRange=8,e.maxEnvelopeCount=12,e.defaultAutomationRange=13,e.instrumentAutomationTargets=o([{name:"none",computeIndex:null,displayName:"none",interleave:!1,isFilter:!1,maxCount:1,effect:null,compatibleInstruments:null},{name:"noteVolume",computeIndex:0,displayName:"note volume",interleave:!1,isFilter:!1,maxCount:1,effect:null,compatibleInstruments:null},{name:"pulseWidth",computeIndex:2,displayName:"pulse width",interleave:!1,isFilter:!1,maxCount:1,effect:null,compatibleInstruments:[6]},{name:"stringSustain",computeIndex:3,displayName:"sustain",interleave:!1,isFilter:!1,maxCount:1,effect:null,compatibleInstruments:[7]},{name:"unison",computeIndex:4,displayName:"unison",interleave:!1,isFilter:!1,maxCount:1,effect:null,compatibleInstruments:[0,5,7]},{name:"operatorFrequency",computeIndex:5,displayName:"fm# freq",interleave:!0,isFilter:!1,maxCount:e.operatorCount,effect:null,compatibleInstruments:[1]},{name:"operatorAmplitude",computeIndex:9,displayName:"fm# volume",interleave:!1,isFilter:!1,maxCount:e.operatorCount,effect:null,compatibleInstruments:[1]},{name:"feedbackAmplitude",computeIndex:13,displayName:"fm feedback",interleave:!1,isFilter:!1,maxCount:1,effect:null,compatibleInstruments:[1]},{name:"pitchShift",computeIndex:14,displayName:"pitch shift",interleave:!1,isFilter:!1,maxCount:1,effect:7,compatibleInstruments:null},{name:"detune",computeIndex:15,displayName:"detune",interleave:!1,isFilter:!1,maxCount:1,effect:8,compatibleInstruments:null},{name:"vibratoDepth",computeIndex:16,displayName:"vibrato range",interleave:!1,isFilter:!1,maxCount:1,effect:9,compatibleInstruments:null},{name:"noteFilterAllFreqs",computeIndex:1,displayName:"n. filter freqs",interleave:!1,isFilter:!0,maxCount:1,effect:5,compatibleInstruments:null},{name:"noteFilterFreq",computeIndex:17,displayName:"n. filter # freq",interleave:!1,isFilter:!0,maxCount:e.filterMaxPoints,effect:5,compatibleInstruments:null}]);class D{constructor(){this.t=1,this.i=[void 0],this.h=0,this.o=0,this.l=0}pushFront(t){this.l>=this.t&&this.u(),this.o=this.o-1&this.h,this.i[this.o]=t,this.l++}pushBack(t){this.l>=this.t&&this.u(),this.i[this.o+this.l&this.h]=t,this.l++}popFront(){if(this.l<=0)throw new Error("No elements left to pop.");const t=this.i[this.o];return this.i[this.o]=void 0,this.o=this.o+1&this.h,this.l--,t}popBack(){if(this.l<=0)throw new Error("No elements left to pop.");this.l--;const t=this.o+this.l&this.h,e=this.i[t];return this.i[t]=void 0,e}peakFront(){if(this.l<=0)throw new Error("No elements left to pop.");return this.i[this.o]}peakBack(){if(this.l<=0)throw new Error("No elements left to pop.");return this.i[this.o+this.l-1&this.h]}count(){return this.l}set(t,e){if(t<0||t>=this.l)throw new Error("Invalid index");this.i[this.o+t&this.h]=e}get(t){if(t<0||t>=this.l)throw new Error("Invalid index");return this.i[this.o+t&this.h]}remove(t){if(t<0||t>=this.l)throw new Error("Invalid index");if(t<=this.l>>1){for(;t>0;)this.set(t,this.get(t-1)),t--;this.popFront()}else{for(t++;t<this.l;)this.set(t-1,this.get(t)),t++;this.popBack()}}u(){if(this.t>=1073741824)throw new Error("Capacity too big.");this.t=this.t<<1;const t=this.i,e=new Array(this.t),s=0|this.l,n=0|this.o;for(let i=0;i<s;i++)e[i]=t[n+i&this.h];for(let t=s;t<this.t;t++)e[t]=void 0;this.o=0,this.i=e,this.h=this.t-1}}class F{constructor(){this.a=[1],this.b=[1],this.order=0}linearGain0thOrder(t){this.b[0]=t,this.order=0}lowPass1stOrderButterworth(t){const e=1/Math.tan(.5*t),s=1+e;this.a[1]=(1-e)/s,this.b[1]=this.b[0]=1/s,this.order=1}lowPass1stOrderSimplified(t){const e=2*Math.sin(.5*t);this.a[1]=e-1,this.b[0]=e,this.b[1]=0,this.order=1}highPass1stOrderButterworth(t){const e=1/Math.tan(.5*t),s=1+e;this.a[1]=(1-e)/s,this.b[0]=e/s,this.b[1]=-e/s,this.order=1}highShelf1stOrder(t,e){const s=Math.tan(.5*t),n=Math.sqrt(e),i=(s*n-1)/(s*n+1);this.a[1]=i/1,this.b[0]=(1+i+e*(1-i))/2,this.b[1]=(1+i-e*(1-i))/2,this.order=1}allPass1stOrderInvertPhaseAbove(t){const e=(Math.sin(t)-1)/Math.cos(t);this.a[1]=e,this.b[0]=e,this.b[1]=1,this.order=1}allPass1stOrderFractionalDelay(t){const e=(1-t)/(1+t);this.a[1]=e,this.b[0]=e,this.b[1]=1,this.order=1}lowPass2ndOrderButterworth(t,e){const s=Math.sin(t)/(2*e),n=Math.cos(t),i=1+s;this.a[1]=-2*n/i,this.a[2]=(1-s)/i,this.b[2]=this.b[0]=(1-n)/(2*i),this.b[1]=(1-n)/i,this.order=2}lowPass2ndOrderSimplified(t,e){const s=2*Math.sin(t/2),n=1-1/(2*e),i=n+n/(1-s);this.a[1]=2*s+(s-1)*s*i-2,this.a[2]=(s-1)*(s-s*i-1),this.b[0]=s*s,this.b[1]=0,this.b[2]=0,this.order=2}highPass2ndOrderButterworth(t,e){const s=Math.sin(t)/(2*e),n=Math.cos(t),i=1+s;this.a[1]=-2*n/i,this.a[2]=(1-s)/i,this.b[2]=this.b[0]=(1+n)/(2*i),this.b[1]=-(1+n)/i,this.order=2}peak2ndOrder(t,e,s){const n=Math.sqrt(e),i=s*t/(n>=1?n:1/n),a=Math.tan(.5*i),r=1+a/n;this.b[0]=(1+a*n)/r,this.b[1]=this.a[1]=-2*Math.cos(t)/r,this.b[2]=(1-a*n)/r,this.a[2]=(1-a/n)/r,this.order=2}}class x{constructor(){this.real=0,this.imag=0,this.denom=1}analyze(t,e){this.analyzeComplex(t,Math.cos(e),Math.sin(e))}analyzeComplex(t,e,s){const n=t.a,i=t.b,a=e,r=-s;let h=i[0]+i[1]*a,o=i[1]*r,l=1+n[1]*a,c=n[1]*r,u=a,f=r;for(let e=2;e<=t.order;e++){const t=u*r+f*a;u=u*a-f*r,f=t,h+=i[e]*u,o+=i[e]*f,l+=n[e]*u,c+=n[e]*f}this.denom=l*l+c*c,this.real=h*l+o*c,this.imag=o*l-h*c}magnitude(){return Math.sqrt(this.real*this.real+this.imag*this.imag)/this.denom}angle(){return Math.atan2(this.imag,this.real)}}class L{constructor(){this.a1=0,this.a2=0,this.b0=1,this.b1=0,this.b2=0,this.a1Delta=0,this.a2Delta=0,this.b0Delta=0,this.b1Delta=0,this.b2Delta=0,this.output1=0,this.output2=0,this.useMultiplicativeInputCoefficients=!1}resetOutput(){this.output1=0,this.output2=0}loadCoefficientsWithGradient(t,e,s,n){if(2!=t.order||2!=e.order)throw new Error;this.a1=t.a[1],this.a2=t.a[2],this.b0=t.b[0],this.b1=t.b[1],this.b2=t.b[2],this.a1Delta=(e.a[1]-t.a[1])*s,this.a2Delta=(e.a[2]-t.a[2])*s,n?(this.b0Delta=Math.pow(e.b[0]/t.b[0],s),this.b1Delta=Math.pow(e.b[1]/t.b[1],s),this.b2Delta=Math.pow(e.b[2]/t.b[2],s)):(this.b0Delta=(e.b[0]-t.b[0])*s,this.b1Delta=(e.b[1]-t.b[1])*s,this.b2Delta=(e.b[2]-t.b[2])*s),this.useMultiplicativeInputCoefficients=n}}const T=1e-24,w=[48,49,50,51,52,53,54,55,56,57,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,45,95],k=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,62,62,0,0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,0,0,0,0,63,0,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,0,0,0,0,0];class O{constructor(t,e,s){this.p=[],this.m=0;for(let n=e;n<s;n++){const e=k[t.charCodeAt(n)];this.p.push(e>>5&1),this.p.push(e>>4&1),this.p.push(e>>3&1),this.p.push(e>>2&1),this.p.push(e>>1&1),this.p.push(1&e)}}read(t){let e=0;for(;t>0;)e<<=1,e+=this.p[this.m++],t--;return e}readLongTail(t,e){let s=t,n=e;for(;this.p[this.m++];)s+=1<<n,n++;for(;n>0;)n--,this.p[this.m++]&&(s+=1<<n);return s}readPartDuration(){return this.readLongTail(1,3)}readLegacyPartDuration(){return this.readLongTail(1,2)}readPinCount(){return this.readLongTail(1,0)}readPitchInterval(){return this.read(1)?-this.readLongTail(1,3):this.readLongTail(1,3)}}class R{constructor(){this.S=0,this.p=[]}clear(){this.S=0}write(t,e){for(t--;t>=0;)this.p[this.S++]=e>>>t&1,t--}writeLongTail(t,e,s){if(s<t)throw new Error("value out of bounds");s-=t;let n=e;for(;s>=1<<n;)this.p[this.S++]=1,s-=1<<n,n++;for(this.p[this.S++]=0;n>0;)n--,this.p[this.S++]=s>>>n&1}writePartDuration(t){this.writeLongTail(1,3,t)}writePinCount(t){this.writeLongTail(1,0,t)}writePitchInterval(t){t<0?(this.write(1,1),this.writeLongTail(1,3,-t)):(this.write(1,0),this.writeLongTail(1,3,t))}concat(t){for(let e=0;e<t.S;e++)this.p[this.S++]=t.p[e]}encodeBase64(t){for(let e=0;e<this.S;e+=6){const s=this.p[e]<<5|this.p[e+1]<<4|this.p[e+2]<<3|this.p[e+3]<<2|this.p[e+4]<<1|this.p[e+5];t.push(w[s])}return t}lengthBase64(){return Math.ceil(this.S/6)}}function C(t,e,s){return{interval:t,time:e,size:s}}function E(t,e,s){return s<=(e-=1)?s>=t?s:t:e}function B(t,e,s){if(t<=s&&s<=e)return s;throw new Error(`Value ${s} not in range [${t}, ${e}]`)}class A{constructor(t,e,s,n,i=!1){this.pitches=[t],this.pins=[C(0,0,n),C(0,s-e,i?0:n)],this.start=e,this.end=s,this.continuesLastPattern=!1}pickMainInterval(){let t=0,e=0;for(let s=1;s<this.pins.length;s++){const n=this.pins[s-1],i=this.pins[s];if(n.interval==i.interval){const s=i.time-n.time;t<s&&(t=s,e=n.interval)}}if(0==t){let t=0;for(let s=0;s<this.pins.length;s++){const n=this.pins[s];t<n.size&&(t=n.size,e=n.interval)}}return e}clone(){const t=new A(-1,this.start,this.end,e.noteSizeMax);t.pitches=this.pitches.concat(),t.pins=[];for(const e of this.pins)t.pins.push(C(e.interval,e.time,e.size));return t.continuesLastPattern=this.continuesLastPattern,t}getEndPinIndex(t){let e;for(e=1;e<this.pins.length-1&&!(this.pins[e].time+this.start>t);e++);return e}}class N{constructor(){this.notes=[],this.instruments=[0]}cloneNotes(){const t=[];for(const e of this.notes)t.push(e.clone());return t}reset(){this.notes.length=0,this.instruments[0]=0,this.instruments.length=1}}class z{constructor(t){this.frequency=0,this.amplitude=0,this.reset(t)}reset(t){this.frequency=0,this.amplitude=t<=1?e.operatorAmplitudeMax:0}}class W{constructor(t){this.spectrum=[],this.M=null,this.g=!1,this.reset(t)}reset(t){for(let s=0;s<e.spectrumControlPoints;s++)if(t)this.spectrum[s]=Math.round(e.spectrumMax*(1/Math.sqrt(1+s/3)));else{const t=0==s||7==s||11==s||14==s||16==s||18==s||21==s||23==s||s>=25;this.spectrum[s]=t?Math.max(0,Math.round(e.spectrumMax*(1-s/30))):0}this.g=!1}markCustomWaveDirty(){this.g=!1}getCustomWave(t){if(this.g)return this.M;const s=e.spectrumNoiseLength;null!=this.M&&this.M.length==s+1||(this.M=new Float32Array(s+1));const n=this.M;for(let t=0;t<s;t++)n[t]=0;const i=[0,1/7,Math.log2(5/4),3/7,Math.log2(1.5),5/7,6/7];function a(s){return t+Math.floor(s/e.spectrumControlPointsPerOctave)+i[(s+e.spectrumControlPointsPerOctave)%e.spectrumControlPointsPerOctave]}let h=1;for(let t=0;t<e.spectrumControlPoints+1;t++){const i=t<=0?0:this.spectrum[t-1],o=t>=e.spectrumControlPoints?this.spectrum[e.spectrumControlPoints-1]:this.spectrum[t],l=a(t-1);let c=a(t);t>=e.spectrumControlPoints&&(c=14+.25*(c-14)),0==i&&0==o||(h+=.02*r(n,s,l,c,i/e.spectrumMax,o/e.spectrumMax,-.5))}return this.spectrum[e.spectrumControlPoints-1]>0&&(h+=.02*r(n,s,14+.25*(a(e.spectrumControlPoints)-14),14,this.spectrum[e.spectrumControlPoints-1]/e.spectrumMax,0,-.5)),P(n,s),v(n,5/(Math.sqrt(s)*Math.pow(h,.75))),n[s]=n[0],this.g=!0,n}}class V{constructor(){this.harmonics=[],this.M=null,this.g=!1,this.reset()}reset(){for(let t=0;t<e.harmonicsControlPoints;t++)this.harmonics[t]=0;this.harmonics[0]=e.harmonicsMax,this.harmonics[3]=e.harmonicsMax,this.harmonics[6]=e.harmonicsMax,this.g=!1}markCustomWaveDirty(){this.g=!1}getCustomWave(t){this.v!=t&&(this.v=t,this.g=!1);const s=7==t?e.harmonicsRenderedForPickedString:e.harmonicsRendered;if(this.g)return this.M;const i=e.harmonicsWavelength,r=a(0,null,null);null!=this.M&&this.M.length==i+1||(this.M=new Float32Array(i+1));const h=this.M;for(let t=0;t<i;t++)h[t]=0;let o=1;for(let t=0;t<s;t++){const n=t+1;let a=t<e.harmonicsControlPoints?this.harmonics[t]:this.harmonics[e.harmonicsControlPoints-1];t>=e.harmonicsControlPoints&&(a*=1-(t-e.harmonicsControlPoints)/(s-e.harmonicsControlPoints));const l=a/e.harmonicsMax;let c=Math.pow(2,a-e.harmonicsMax+1)*Math.sqrt(l);t<e.harmonicsControlPoints&&(o+=c),c*=Math.pow(n,-.25),c*=r[t+589],h[i-n]=c}P(h,i);const l=1/Math.pow(o,.7);for(let t=0;t<h.length;t++)h[t]*=l;return n(h),h[i]=h[0],this.g=!0,h}}class q{constructor(){this.freq=0,this.gain=e.filterGainCenter,this.type=2}set(t,e){this.freq=t,this.gain=e}getHz(){return q.getHzFromSettingValue(this.freq)}static getHzFromSettingValue(t){return e.filterFreqReferenceHz*Math.pow(2,(t-e.filterFreqReferenceSetting)*e.filterFreqStep)}static getSettingValueFromHz(t){return Math.log2(t/e.filterFreqReferenceHz)/e.filterFreqStep+e.filterFreqReferenceSetting}static getRoundedSettingValueFromHz(t){return Math.max(0,Math.min(e.filterFreqRange-1,Math.round(q.getSettingValueFromHz(t))))}getLinearGain(t=1){const s=(this.gain-e.filterGainCenter)*e.filterGainStep,n=2==this.type?0:-.5,i=n+(s-n)*t;return Math.pow(2,i)}static getRoundedSettingValueFromLinearGain(t){return Math.max(0,Math.min(e.filterGainRange-1,Math.round(Math.log2(t)/e.filterGainStep+e.filterGainCenter)))}toCoefficients(t,s,n=1,i=1){const a=2*Math.PI*Math.max(e.filterFreqMinHz,Math.min(e.filterFreqMaxHz,n*this.getHz()))/s,r=this.getLinearGain(i);switch(this.type){case 0:t.lowPass2ndOrderButterworth(a,r);break;case 1:t.highPass2ndOrderButterworth(a,r);break;case 2:t.peak2ndOrder(a,r,1);break;default:throw new Error}}getVolumeCompensationMult(){const t=(this.freq-e.filterFreqReferenceSetting)*e.filterFreqStep,s=(this.gain-e.filterGainCenter)*e.filterGainStep;switch(this.type){case 0:const n=Math.pow(2,t)*e.filterFreqReferenceHz/8e3,i=(Math.sqrt(1+4*n)-1)/2,a=Math.log2(i);return Math.pow(.5,.2*Math.max(0,s+1)+Math.min(0,Math.max(-3,.595*a+.35*Math.min(0,s+1))));case 1:return Math.pow(.5,.125*Math.max(0,s+1)+Math.min(0,.3*(-t-Math.log2(e.filterFreqReferenceHz/125))+.2*Math.min(0,s+1)));case 2:const r=t+Math.log2(e.filterFreqReferenceHz/2e3),h=Math.pow(1/(1+Math.pow(r/3,2)),2);return Math.pow(.5,.125*Math.max(0,s)+.1*h*Math.min(0,s));default:throw new Error}}}class G{constructor(){this.controlPoints=[],this.controlPointCount=0,this.reset()}reset(){this.controlPointCount=0}addPoint(t,e,s){let n;this.controlPoints.length<=this.controlPointCount?(n=new q,this.controlPoints[this.controlPointCount]=n):n=this.controlPoints[this.controlPointCount],this.controlPointCount++,n.type=t,n.set(e,s)}toJsonObject(){const t=[];for(let s=0;s<this.controlPointCount;s++){const n=this.controlPoints[s];t.push({type:e.filterTypeNames[n.type],cutoffHz:Math.round(100*n.getHz())/100,linearGain:Math.round(1e4*n.getLinearGain())/1e4})}return t}fromJsonObject(t){if(this.controlPoints.length=0,t)for(const s of t){const t=new q;t.type=e.filterTypeNames.indexOf(s.type),-1==t.type&&(t.type=2),null!=s.cutoffHz?t.freq=q.getRoundedSettingValueFromHz(s.cutoffHz):t.freq=0,null!=s.linearGain?t.gain=q.getRoundedSettingValueFromLinearGain(s.linearGain):t.gain=e.filterGainCenter,this.controlPoints.push(t)}this.controlPointCount=this.controlPoints.length}convertLegacySettings(t,e,s){this.reset();const n=2*Math.asin(.475),i=e>1,a=0==e,r=10==t,h=3==s.type||4==s.type||8==s.type||0==s.type,o=48e3,l=8e3*Math.pow(2,.5*(t-10)),c=Math.min(n,2*Math.PI*l/o);if(1==s.type&&!i&&r);else if(a){const t=3.5,e=c*Math.pow(2,t),s=o*(e/(1+e/Math.PI))/(2*Math.PI),n=q.getRoundedSettingValueFromHz(s),i=q.getHzFromSettingValue(n),a=2*Math.PI*i/o,r=new F;r.lowPass1stOrderSimplified(c);const l=new x;l.analyze(r,a);const u=l.magnitude();let f=Math.log2(u);f=.82*(f+t)-t,h&&(f=Math.min(f,-1));const p=Math.pow(2,f),d=q.getRoundedSettingValueFromLinearGain(p);this.addPoint(0,n,d)}else{const t=.5/(1-.95*Math.sqrt(Math.max(0,e-1)/6)),s=.5/t,n=c+(c*(c/(2*Math.PI*8e3/o)*Math.pow(s,.9)+1)-c)*s;let a;a=h?o*Math.min(n,c*Math.pow(2,.25))/(2*Math.PI):o*n/(2*Math.PI);const r=q.getRoundedSettingValueFromHz(a);let l;if(h)l=t;else{const e=new F;e.lowPass2ndOrderSimplified(c,t);const s=new x;s.analyze(e,n),l=s.magnitude()}i||(l=Math.min(l,Math.sqrt(.5)));const u=q.getRoundedSettingValueFromLinearGain(l);this.addPoint(0,r,u)}}}class U{constructor(){this.target=0,this.index=0,this.envelope=0,this.reset()}reset(){this.target=0,this.index=0,this.envelope=0}toJsonObject(){const t={target:e.instrumentAutomationTargets[this.target].name,envelope:e.envelopes[this.envelope].name};return e.instrumentAutomationTargets[this.target].maxCount>1&&(t.index=this.index),t}fromJsonObject(t){this.reset();let s=e.instrumentAutomationTargets.dictionary[t.target];null==s&&(s=e.instrumentAutomationTargets.dictionary.noteVolume),this.target=s.index;let n=e.envelopes.dictionary[t.envelope];null==n&&(n=e.envelopes.dictionary.none),this.envelope=n.index,null!=t.index?this.index=E(0,e.instrumentAutomationTargets[this.target].maxCount,0|t.index):this.index=0}}class H{constructor(t){this.type=0,this.preset=0,this.chipWave=2,this.chipNoise=1,this.eqFilter=new G,this.noteFilter=new G,this.envelopes=[],this.envelopeCount=0,this.fadeIn=0,this.fadeOut=e.fadeOutNeutral,this.transition=e.transitions.dictionary.normal.index,this.pitchShift=0,this.detune=0,this.vibrato=0,this.unison=0,this.effects=0,this.chord=1,this.volume=0,this.pan=e.panCenter,this.pulseWidth=e.pulseWidthRange-1,this.stringSustain=10,this.distortion=0,this.bitcrusherFreq=0,this.bitcrusherQuantization=0,this.chorus=0,this.reverb=0,this.echoSustain=0,this.echoDelay=0,this.algorithm=0,this.feedbackType=0,this.feedbackAmplitude=0,this.operators=[],this.harmonicsWave=new V,this.drumsetEnvelopes=[],this.drumsetSpectrumWaves=[],this.spectrumWave=new W(t);for(let t=0;t<e.operatorCount;t++)this.operators[t]=new z(t);for(let t=0;t<e.drumCount;t++)this.drumsetEnvelopes[t]=e.envelopes.dictionary["twang 2"].index,this.drumsetSpectrumWaves[t]=new W(!0)}setTypeAndReset(t,s){switch(this.type=t,this.preset=t,this.volume=0,this.effects=0,this.chorus=e.chorusRange-1,this.reverb=2,this.echoSustain=Math.floor(.5*(e.echoSustainRange-1)),this.echoDelay=Math.floor(.5*(e.echoDelayRange-1)),this.eqFilter.reset(),this.noteFilter.reset(),this.distortion=Math.floor(.75*(e.distortionRange-1)),this.bitcrusherFreq=Math.floor(.5*(e.bitcrusherFreqRange-1)),this.bitcrusherQuantization=Math.floor(.5*(e.bitcrusherQuantizationRange-1)),this.pan=e.panCenter,this.pitchShift=e.pitchShiftCenter,this.detune=e.detuneCenter,this.vibrato=0,this.unison=0,this.stringSustain=10,this.fadeIn=0,this.fadeOut=e.fadeOutNeutral,this.transition=e.transitions.dictionary.normal.index,this.envelopeCount=0,t){case 0:this.chipWave=2,this.chord=e.chords.dictionary.arpeggio.index;break;case 1:this.chord=e.chords.dictionary["custom interval"].index,this.algorithm=0,this.feedbackType=0,this.feedbackAmplitude=0;for(let t=0;t<this.operators.length;t++)this.operators[t].reset(t);break;case 2:this.chipNoise=1,this.chord=e.chords.dictionary.arpeggio.index;break;case 3:this.chord=e.chords.dictionary.simultaneous.index,this.spectrumWave.reset(s);break;case 4:this.chord=e.chords.dictionary.simultaneous.index;for(let t=0;t<e.drumCount;t++)this.drumsetEnvelopes[t]=e.envelopes.dictionary["twang 2"].index,this.drumsetSpectrumWaves[t].reset(s);break;case 5:this.chord=e.chords.dictionary.simultaneous.index,this.harmonicsWave.reset();break;case 6:this.chord=e.chords.dictionary.arpeggio.index,this.pulseWidth=e.pulseWidthRange-1;break;case 7:this.chord=e.chords.dictionary.strum.index,this.harmonicsWave.reset();break;default:throw new Error("Unrecognized instrument type: "+t)}this.chord!=e.chords.dictionary.simultaneous.index&&(this.effects=2048|this.effects)}convertLegacySettings(t){let s=t.filterCutoff,n=t.filterResonance,i=t.filterEnvelope,a=t.pulseEnvelope,r=t.operatorEnvelopes,h=t.feedbackEnvelope;null==s&&(s=0==this.type?6:10),null==n&&(n=0),null==i&&(i=e.envelopes.dictionary.none),null==a&&(a=e.envelopes.dictionary[6==this.type?"twang 2":"none"]),null==r&&(r=[e.envelopes.dictionary[1==this.type?"note size":"none"],e.envelopes.dictionary.none,e.envelopes.dictionary.none,e.envelopes.dictionary.none]),null==h&&(h=e.envelopes.dictionary.none);const o=e.algorithms[this.algorithm].carrierCount;let l=!0,c=!0,u=0==i.type||0==a.type;if(1==this.type){u=u||0==h.type;for(let t=0;t<r.length;t++)t<o?0!=r[t].type?c=!1:l=!1:u=u||0==r[t].type}this.envelopeCount=0,1==this.type&&(c&&u?this.addEnvelope(e.instrumentAutomationTargets.dictionary.noteVolume.index,0,e.envelopes.dictionary["note size"].index):l&&!u&&this.addEnvelope(e.instrumentAutomationTargets.dictionary.none.index,0,e.envelopes.dictionary["note size"].index)),1==i.type?(this.noteFilter.reset(),this.eqFilter.convertLegacySettings(s,n,i),this.effects&=-33):(this.eqFilter.reset(),this.noteFilter.convertLegacySettings(s,n,i),this.effects|=32,this.addEnvelope(e.instrumentAutomationTargets.dictionary.noteFilterAllFreqs.index,0,i.index)),1!=a.type&&this.addEnvelope(e.instrumentAutomationTargets.dictionary.pulseWidth.index,0,a.index);for(let t=0;t<r.length;t++)t<o&&c||1!=r[t].type&&this.addEnvelope(e.instrumentAutomationTargets.dictionary.operatorAmplitude.index,t,r[t].index);1!=h.type&&this.addEnvelope(e.instrumentAutomationTargets.dictionary.feedbackAmplitude.index,0,h.index)}toJsonObject(){const t={type:e.instrumentTypeNames[this.type],volume:20*(5-this.volume),eqFilter:this.eqFilter.toJsonObject()};this.preset!=this.type&&(t.preset=this.preset);const s=[];for(const t of e.effectOrder)this.effects&1<<t&&s.push(e.effectNames[t]);if(t.effects=s,l(this.effects)&&(t.transition=e.transitions[this.transition].name),c(this.effects)&&(t.chord=this.getChord().name),u(this.effects)&&(t.pitchShiftSemitones=this.pitchShift),f(this.effects)&&(t.detuneCents=X.detuneToCents(this.detune-e.detuneCenter)),p(this.effects)&&(t.vibrato=e.vibratos[this.vibrato].name),d(this.effects)&&(t.noteFilter=this.noteFilter.toJsonObject()),m(this.effects)&&(t.distortion=Math.round(100*this.distortion/(e.distortionRange-1))),S(this.effects)&&(t.bitcrusherOctave=(e.bitcrusherFreqRange-1-this.bitcrusherFreq)*e.bitcrusherOctaveStep,t.bitcrusherQuantization=Math.round(100*this.bitcrusherQuantization/(e.bitcrusherQuantizationRange-1))),y(this.effects)&&(t.pan=Math.round(100*(this.pan-e.panCenter)/e.panCenter)),b(this.effects)&&(t.chorus=Math.round(100*this.chorus/(e.chorusRange-1))),M(this.effects)&&(t.echoSustain=Math.round(100*this.echoSustain/(e.echoSustainRange-1)),t.echoDelayBeats=Math.round(1e3*(this.echoDelay+1)*e.echoDelayStepTicks/(e.ticksPerPart*e.partsPerBeat))/1e3),g(this.effects)&&(t.reverb=Math.round(100*this.reverb/(e.reverbRange-1))),4!=this.type&&(t.fadeInSeconds=Math.round(1e4*X.fadeInSettingToSeconds(this.fadeIn))/1e4,t.fadeOutTicks=X.fadeOutSettingToTicks(this.fadeOut)),5==this.type||7==this.type){t.harmonics=[];for(let s=0;s<e.harmonicsControlPoints;s++)t.harmonics[s]=Math.round(100*this.harmonicsWave.harmonics[s]/e.harmonicsMax)}if(2==this.type)t.wave=e.chipNoises[this.chipNoise].name;else if(3==this.type){t.spectrum=[];for(let s=0;s<e.spectrumControlPoints;s++)t.spectrum[s]=Math.round(100*this.spectrumWave.spectrum[s]/e.spectrumMax)}else if(4==this.type){t.drums=[];for(let s=0;s<e.drumCount;s++){const n=[];for(let t=0;t<e.spectrumControlPoints;t++)n[t]=Math.round(100*this.drumsetSpectrumWaves[s].spectrum[t]/e.spectrumMax);t.drums[s]={filterEnvelope:this.getDrumsetEnvelope(s).name,spectrum:n}}}else if(0==this.type)t.wave=e.chipWaves[this.chipWave].name,t.unison=e.unisons[this.unison].name;else if(6==this.type)t.pulseWidth=Math.round(100*i(this.pulseWidth)*1e5)/1e5;else if(7==this.type)t.unison=e.unisons[this.unison].name,t.stringSustain=Math.round(100*this.stringSustain/(e.stringSustainRange-1));else if(5==this.type)t.unison=e.unisons[this.unison].name;else{if(1!=this.type)throw new Error("Unrecognized instrument type");{const s=[];for(const t of this.operators)s.push({frequency:e.operatorFrequencies[t.frequency].name,amplitude:t.amplitude});t.algorithm=e.algorithms[this.algorithm].name,t.feedbackType=e.feedbacks[this.feedbackType].name,t.feedbackAmplitude=this.feedbackAmplitude,t.operators=s}}const n=[];for(let t=0;t<this.envelopeCount;t++)n.push(this.envelopes[t].toJsonObject());return t.envelopes=n,t}fromJsonObject(t,s,n=0){null==t&&(t={});let i=e.instrumentTypeNames.indexOf(t.type);if(-1==i&&(i=s?2:0),this.setTypeAndReset(i,s),null!=t.preset&&(this.preset=t.preset>>>0),null!=t.volume?this.volume=E(0,e.volumeRange,Math.round(5-(0|t.volume)/20)):this.volume=0,Array.isArray(t.effects)){let s=0;for(let n=0;n<t.effects.length;n++)s|=1<<e.effectNames.indexOf(t.effects[n]);this.effects=4095&s}else{const e=["none","reverb","chorus","chorus & reverb"];this.effects=e.indexOf(t.effects),-1==this.effects&&(this.effects=2==this.type?0:1)}this.transition=e.transitions.dictionary.normal.index;const a=t.transition||t.envelope;if(null!=a){let s=e.transitions.dictionary[a];if(null==t.fadeInSeconds||null==t.fadeOutTicks){const t={binary:{transition:"interrupt",fadeInSeconds:0,fadeOutTicks:-1},seamless:{transition:"interrupt",fadeInSeconds:0,fadeOutTicks:-1},sudden:{transition:"normal",fadeInSeconds:0,fadeOutTicks:-3},hard:{transition:"normal",fadeInSeconds:0,fadeOutTicks:-3},smooth:{transition:"normal",fadeInSeconds:.025,fadeOutTicks:-3},soft:{transition:"normal",fadeInSeconds:.025,fadeOutTicks:-3},slide:{transition:"slide in pattern",fadeInSeconds:.025,fadeOutTicks:-3},"cross fade":{transition:"normal",fadeInSeconds:.04,fadeOutTicks:6},"hard fade":{transition:"normal",fadeInSeconds:0,fadeOutTicks:48},"medium fade":{transition:"normal",fadeInSeconds:.0125,fadeOutTicks:72},"soft fade":{transition:"normal",fadeInSeconds:.06,fadeOutTicks:96}}[a];null!=t&&(s=e.transitions.dictionary[t.transition],this.fadeIn=X.secondsToFadeInSetting(t.fadeInSeconds),this.fadeOut=X.ticksToFadeOutSetting(t.fadeOutTicks))}null!=s&&(this.transition=s.index),this.transition!=e.transitions.dictionary.normal.index&&(this.effects=1024|this.effects)}null!=t.fadeInSeconds&&(this.fadeIn=X.secondsToFadeInSetting(+t.fadeInSeconds)),null!=t.fadeOutTicks&&(this.fadeOut=X.ticksToFadeOutSetting(+t.fadeOutTicks));{const s=t.chord,n={harmony:"simultaneous"},i=e.chords.dictionary[n[s]]||e.chords.dictionary[s];null!=i?this.chord=i.index:2==this.type?this.chord=e.chords.dictionary.arpeggio.index:7==this.type?this.chord=e.chords.dictionary.strum.index:0==this.type?this.chord=e.chords.dictionary.arpeggio.index:1==this.type?this.chord=e.chords.dictionary["custom interval"].index:this.chord=e.chords.dictionary.simultaneous.index}this.unison=e.unisons.dictionary.none.index;const r=t.unison||t.interval||t.chorus;if(null!=r){const t={union:"none",fifths:"fifth",octaves:"octave"},s=e.unisons.dictionary[t[r]]||e.unisons.dictionary[r];null!=s&&(this.unison=s.index)}"custom harmony"==t.chorus&&(this.unison=e.unisons.dictionary.hum.index,this.chord=e.chords.dictionary["custom interval"].index),this.chord==e.chords.dictionary.simultaneous.index||Array.isArray(t.effects)||(this.effects=2048|this.effects),null!=t.pitchShiftSemitones&&(this.pitchShift=E(0,e.pitchShiftRange,Math.round(+t.pitchShiftSemitones))),null!=t.detuneCents&&(this.detune=E(0,e.detuneMax+1,Math.round(e.detuneCenter+X.centsToDetune(+t.detuneCents)))),this.vibrato=e.vibratos.dictionary.none.index;const h=t.vibrato||t.effect;if(null!=h){const t={"vibrato light":"light","vibrato delayed":"delayed","vibrato heavy":"heavy"},s=e.vibratos.dictionary[t[r]]||e.vibratos.dictionary[h];null!=s&&(this.vibrato=s.index),s!=e.vibratos.dictionary.none&&(this.effects=512|this.effects)}if(null!=t.pan?(this.pan=E(0,e.panMax+1,Math.round(e.panCenter+(0|t.pan)*e.panCenter/100)),this.pan!=e.panCenter&&(this.effects=4|this.effects)):this.pan=e.panCenter,null!=t.distortion&&(this.distortion=E(0,e.distortionRange,Math.round((e.distortionRange-1)*(0|t.distortion)/100))),null!=t.bitcrusherOctave&&(this.bitcrusherFreq=e.bitcrusherFreqRange-1-+t.bitcrusherOctave/e.bitcrusherOctaveStep),null!=t.bitcrusherQuantization&&(this.bitcrusherQuantization=E(0,e.bitcrusherQuantizationRange,Math.round((e.bitcrusherQuantizationRange-1)*(0|t.bitcrusherQuantization)/100))),null!=t.echoSustain&&(this.echoSustain=E(0,e.echoSustainRange,Math.round((e.echoSustainRange-1)*(0|t.echoSustain)/100))),null!=t.echoDelayBeats&&(this.echoDelay=E(0,e.echoDelayRange,Math.round(+t.echoDelayBeats*(e.ticksPerPart*e.partsPerBeat)/e.echoDelayStepTicks-1))),isNaN(t.chorus)||(this.chorus=E(0,e.chorusRange,Math.round((e.chorusRange-1)*(0|t.chorus)/100))),null!=t.reverb?this.reverb=E(0,e.reverbRange,Math.round((e.reverbRange-1)*(0|t.reverb)/100)):0==n?this.effects=-2&this.effects:this.reverb=n,null!=t.pulseWidth?this.pulseWidth=E(0,e.pulseWidthRange,Math.round(Math.log2(+t.pulseWidth/50)/.5-1+8)):this.pulseWidth=e.pulseWidthRange-1,null!=t.harmonics)for(let s=0;s<e.harmonicsControlPoints;s++)this.harmonicsWave.harmonics[s]=Math.max(0,Math.min(e.harmonicsMax,Math.round(e.harmonicsMax*+t.harmonics[s]/100)));else this.harmonicsWave.reset();if(null!=t.spectrum)for(let s=0;s<e.spectrumControlPoints;s++)this.spectrumWave.spectrum[s]=Math.max(0,Math.min(e.spectrumMax,Math.round(e.spectrumMax*+t.spectrum[s]/100)));else this.spectrumWave.reset(s);null!=t.stringSustain?this.stringSustain=E(0,e.stringSustainRange,Math.round((e.stringSustainRange-1)*(0|t.stringSustain)/100)):this.stringSustain=10,2==this.type&&(this.chipNoise=e.chipNoises.findIndex((e=>e.name==t.wave)),-1==this.chipNoise&&(this.chipNoise=1));const o={custom:"note size",steady:"none","pluck 1":"twang 1","pluck 2":"twang 2","pluck 3":"twang 3"},l=t=>null!=o[t]?e.envelopes.dictionary[o[t]]:e.envelopes.dictionary[t];if(4==this.type&&null!=t.drums)for(let s=0;s<e.drumCount;s++){const n=t.drums[s];if(null!=n){if(this.drumsetEnvelopes[s]=e.envelopes.dictionary["twang 2"].index,null!=n.filterEnvelope){const t=l(n.filterEnvelope);null!=t&&(this.drumsetEnvelopes[s]=t.index)}if(null!=n.spectrum)for(let t=0;t<e.spectrumControlPoints;t++)this.drumsetSpectrumWaves[s].spectrum[t]=Math.max(0,Math.min(e.spectrumMax,Math.round(e.spectrumMax*+n.spectrum[t]/100)))}}if(0==this.type){const s={triangle:1,square:2,"pulse wide":3,"pulse narrow":4,sawtooth:5,"double saw":6,"double pulse":7,spiky:8,plateau:0};this.chipWave=null!=s[t.wave]?s[t.wave]:e.chipWaves.findIndex((e=>e.name==t.wave)),-1==this.chipWave&&(this.chipWave=1)}if(1==this.type){this.algorithm=e.algorithms.findIndex((e=>e.name==t.algorithm)),-1==this.algorithm&&(this.algorithm=0),this.feedbackType=e.feedbacks.findIndex((e=>e.name==t.feedbackType)),-1==this.feedbackType&&(this.feedbackType=0),null!=t.feedbackAmplitude?this.feedbackAmplitude=E(0,e.operatorAmplitudeMax+1,0|t.feedbackAmplitude):this.feedbackAmplitude=0;for(let s=0;s<e.operatorCount;s++){const n=this.operators[s];let i;null!=t.operators&&(i=t.operators[s]),null==i&&(i={}),n.frequency=e.operatorFrequencies.findIndex((t=>t.name==i.frequency)),-1==n.frequency&&(n.frequency=0),null!=i.amplitude?n.amplitude=E(0,e.operatorAmplitudeMax+1,0|i.amplitude):n.amplitude=0}}if(null!=t.noteFilter?this.noteFilter.fromJsonObject(t.noteFilter):this.noteFilter.reset(),Array.isArray(t.eqFilter))this.eqFilter.fromJsonObject(t.eqFilter);else{this.eqFilter.reset();const s={},n=8e3,i=11,a=8;if(null!=t.filterCutoffHz?s.filterCutoff=E(0,i,Math.round(i-1+2*Math.log((0|t.filterCutoffHz)/n)/Math.LN2)):s.filterCutoff=0==this.type?6:10,null!=t.filterResonance?s.filterResonance=E(0,a,Math.round((a-1)*(0|t.filterResonance)/100)):s.filterResonance=0,s.filterEnvelope=l(t.filterEnvelope),s.pulseEnvelope=l(t.pulseEnvelope),s.feedbackEnvelope=l(t.feedbackEnvelope),Array.isArray(t.operators)){s.operatorEnvelopes=[];for(let n=0;n<e.operatorCount;n++){let i;null!=t.operators[n]&&(i=l(t.operators[n].envelope)),s.operatorEnvelopes[n]=null!=i?i:e.envelopes.dictionary.none}}if(null!=t.filter){const e=[10,6,3,0,8,5,2],n=["none","none","none","none","decay 1","decay 2","decay 3"],i=["none","bright","medium","soft","decay bright","decay medium","decay soft"],a={"sustain sharp":1,"sustain medium":2,"sustain soft":3,"decay sharp":4};let r=null!=a[t.filter]?a[t.filter]:i.indexOf(t.filter);-1==r&&(r=0),s.filterCutoff=e[r],s.filterEnvelope=l(n[r]),s.filterResonance=0}this.convertLegacySettings(s)}if(Array.isArray(t.envelopes)){const s=t.envelopes;for(let t=0;t<s.length&&!(this.envelopeCount>=e.maxEnvelopeCount);t++){const e=new U;e.fromJsonObject(s[t]),this.addEnvelope(e.target,e.index,e.envelope)}}}static frequencyFromPitch(t){return 440*Math.pow(2,(t-69)/12)}static drumsetIndexReferenceDelta(t){return H.frequencyFromPitch(e.spectrumBasePitch+6*t)/44100}static I(t){return 15+Math.log2(H.drumsetIndexReferenceDelta(t))}addEnvelope(t,s,n){if(!this.supportsEnvelopeTarget(t,s))throw new Error;if(this.envelopeCount>=e.maxEnvelopeCount)throw new Error;for(;this.envelopes.length<=this.envelopeCount;)this.envelopes[this.envelopes.length]=new U;const i=this.envelopes[this.envelopeCount];i.target=t,i.index=s,i.envelope=n,this.envelopeCount++}supportsEnvelopeTarget(t,s){const n=e.instrumentAutomationTargets[t];return!(s>=n.maxCount)&&((null==n.compatibleInstruments||-1!=n.compatibleInstruments.indexOf(this.type))&&((null==n.effect||0!=(this.effects&1<<n.effect))&&!(n.isFilter&&s>=this.noteFilter.controlPointCount)))}clearInvalidEnvelopeTargets(){for(let t=0;t<this.envelopeCount;t++){const s=this.envelopes[t].target,n=this.envelopes[t].index;this.supportsEnvelopeTarget(s,n)||(this.envelopes[t].target=e.instrumentAutomationTargets.dictionary.none.index,this.envelopes[t].index=0)}}warmUp(t){if(2==this.type)a(this.chipNoise,P,v);else if(5==this.type)this.harmonicsWave.getCustomWave(this.type);else if(7==this.type)this.harmonicsWave.getCustomWave(this.type);else if(3==this.type)this.spectrumWave.getCustomWave(8);else if(4==this.type)for(let t=0;t<e.drumCount;t++)this.drumsetSpectrumWaves[t].getCustomWave(H.I(t))}getDrumWave(){if(2==this.type)return a(this.chipNoise,P,v);if(3==this.type)return this.spectrumWave.getCustomWave(8);throw new Error("Unhandled instrument type in getDrumWave")}getDrumsetWave(t){if(4==this.type)return this.drumsetSpectrumWaves[t].getCustomWave(H.I(t));throw new Error("Unhandled instrument type in getDrumsetWave")}getTransition(){return l(this.effects)?e.transitions[this.transition]:e.transitions.dictionary.normal}getFadeInSeconds(){return 4==this.type?0:X.fadeInSettingToSeconds(this.fadeIn)}getFadeOutTicks(){return 4==this.type?e.drumsetFadeOutTicks:X.fadeOutSettingToTicks(this.fadeOut)}getChord(){return c(this.effects)?e.chords[this.chord]:e.chords.dictionary.simultaneous}getDrumsetEnvelope(t){if(4!=this.type)throw new Error("Can't getDrumsetEnvelope() for non-drumset.");return e.envelopes[this.drumsetEnvelopes[t]]}}class j{constructor(){this.octave=0,this.instruments=[],this.patterns=[],this.bars=[],this.muted=!1}}class K{constructor(t){this.channels=[],null!=t?this.fromBase64String(t):this.initToDefault(!0)}getChannelCount(){return this.pitchChannelCount+this.noiseChannelCount}getMaxInstrumentsPerChannel(){return Math.max(this.layeredInstruments?e.layeredInstrumentCountMax:e.instrumentCountMin,this.patternInstruments?e.patternInstrumentCountMax:e.instrumentCountMin)}getMaxInstrumentsPerPattern(t){return this.getMaxInstrumentsPerPatternForChannel(this.channels[t])}getMaxInstrumentsPerPatternForChannel(t){return this.layeredInstruments?Math.min(e.layeredInstrumentCountMax,t.instruments.length):1}getChannelIsNoise(t){return t>=this.pitchChannelCount}initToDefault(t=!0){if(this.scale=0,this.key=0,this.loopStart=0,this.loopLength=4,this.tempo=150,this.beatsPerBar=8,this.barCount=16,this.patternsPerChannel=8,this.rhythm=1,this.layeredInstruments=!1,this.patternInstruments=!1,t){this.pitchChannelCount=3,this.noiseChannelCount=1;for(let t=0;t<this.getChannelCount();t++){const s=t>=this.pitchChannelCount;this.channels.length<=t&&(this.channels[t]=new j);const n=this.channels[t];n.octave=s?0:4-t;for(let t=0;t<this.patternsPerChannel;t++)n.patterns.length<=t?n.patterns[t]=new N:n.patterns[t].reset();n.patterns.length=this.patternsPerChannel;for(let t=0;t<e.instrumentCountMin;t++)n.instruments.length<=t&&(n.instruments[t]=new H(s)),n.instruments[t].setTypeAndReset(s?2:0,s);n.instruments.length=e.instrumentCountMin;for(let t=0;t<this.barCount;t++)n.bars[t]=t<4?1:0;n.bars.length=this.barCount}this.channels.length=this.getChannelCount()}}toBase64String(){let t,s=[];if(s.push(w[K.P]),s.push(110,w[this.pitchChannelCount],w[this.noiseChannelCount]),s.push(115,w[this.scale]),s.push(107,w[this.key]),s.push(108,w[this.loopStart>>6],w[63&this.loopStart]),s.push(101,w[this.loopLength-1>>6],w[this.loopLength-1&63]),s.push(116,w[this.tempo>>6],w[63&this.tempo]),s.push(97,w[this.beatsPerBar-1]),s.push(103,w[this.barCount-1>>6],w[this.barCount-1&63]),s.push(106,w[this.patternsPerChannel-1>>6],w[this.patternsPerChannel-1&63]),s.push(114,w[this.rhythm]),s.push(105,w[this.layeredInstruments<<1|this.patternInstruments]),this.layeredInstruments||this.patternInstruments)for(let t=0;t<this.getChannelCount();t++)s.push(w[this.channels[t].instruments.length-e.instrumentCountMin]);s.push(111);for(let t=0;t<this.pitchChannelCount;t++)s.push(w[this.channels[t].octave]);for(let t=0;t<this.getChannelCount();t++)for(let n=0;n<this.channels[t].instruments.length;n++){const i=this.channels[t].instruments[n];s.push(84,w[i.type]),s.push(118,w[i.volume]),s.push(117,w[i.preset>>6],w[63&i.preset]),s.push(102,w[i.eqFilter.controlPointCount]);for(let t=0;t<i.eqFilter.controlPointCount;t++){const e=i.eqFilter.controlPoints[t];s.push(w[e.type],w[e.freq],w[e.gain])}if(s.push(113,w[i.effects>>6],w[63&i.effects]),d(i.effects)){s.push(w[i.noteFilter.controlPointCount]);for(let t=0;t<i.noteFilter.controlPointCount;t++){const e=i.noteFilter.controlPoints[t];s.push(w[e.type],w[e.freq],w[e.gain])}}if(l(i.effects)&&s.push(w[i.transition]),c(i.effects)&&s.push(w[i.chord]),u(i.effects)&&s.push(w[i.pitchShift]),f(i.effects)&&s.push(w[i.detune]),p(i.effects)&&s.push(w[i.vibrato]),m(i.effects)&&s.push(w[i.distortion]),S(i.effects)&&s.push(w[i.bitcrusherFreq],w[i.bitcrusherQuantization]),y(i.effects)&&s.push(w[i.pan]),b(i.effects)&&s.push(w[i.chorus]),M(i.effects)&&s.push(w[i.echoSustain],w[i.echoDelay]),g(i.effects)&&s.push(w[i.reverb]),4!=i.type&&s.push(100,w[i.fadeIn],w[i.fadeOut]),5==i.type||7==i.type){s.push(72);const t=new R;for(let s=0;s<e.harmonicsControlPoints;s++)t.write(e.harmonicsControlPointBits,i.harmonicsWave.harmonics[s]);t.encodeBase64(s)}if(0==i.type)s.push(119,w[i.chipWave]),s.push(104,w[i.unison]);else if(1==i.type){s.push(65,w[i.algorithm]),s.push(70,w[i.feedbackType]),s.push(66,w[i.feedbackAmplitude]),s.push(81);for(let t=0;t<e.operatorCount;t++)s.push(w[i.operators[t].frequency]);s.push(80);for(let t=0;t<e.operatorCount;t++)s.push(w[i.operators[t].amplitude])}else if(2==i.type)s.push(119,w[i.chipNoise]);else if(3==i.type){s.push(83);const t=new R;for(let s=0;s<e.spectrumControlPoints;s++)t.write(e.spectrumControlPointBits,i.spectrumWave.spectrum[s]);t.encodeBase64(s)}else if(4==i.type){s.push(122);for(let t=0;t<e.drumCount;t++)s.push(w[i.drumsetEnvelopes[t]]);s.push(83);const t=new R;for(let s=0;s<e.drumCount;s++)for(let n=0;n<e.spectrumControlPoints;n++)t.write(e.spectrumControlPointBits,i.drumsetSpectrumWaves[s].spectrum[n]);t.encodeBase64(s)}else if(5==i.type)s.push(104,w[i.unison]);else if(6==i.type)s.push(87,w[i.pulseWidth]);else{if(7!=i.type)throw new Error("Unknown instrument type.");s.push(104,w[i.unison]),s.push(73,w[i.stringSustain])}s.push(69,w[i.envelopeCount]);for(let t=0;t<i.envelopeCount;t++)s.push(w[i.envelopes[t].target]),e.instrumentAutomationTargets[i.envelopes[t].target].maxCount>1&&s.push(w[i.envelopes[t].index]),s.push(w[i.envelopes[t].envelope])}s.push(98),t=new R;let n=0;for(;1<<n<this.patternsPerChannel+1;)n++;for(let e=0;e<this.getChannelCount();e++)for(let s=0;s<this.barCount;s++)t.write(n,this.channels[e].bars[s]);t.encodeBase64(s),s.push(112),t=new R;const i=new R,a=K.getNeededBits(e.noteSizeMax);for(let s=0;s<this.getChannelCount();s++){const n=this.channels[s],r=this.getMaxInstrumentsPerPattern(s),h=K.getNeededBits(r-e.instrumentCountMin),o=K.getNeededBits(n.instruments.length-1),l=this.getChannelIsNoise(s),c=l?0:n.octave*e.pitchesPerOctave;let u=l?4:c;const f=l?[4,6,7,2,3,8,0,10]:[0,7,12,19,24,-5,-12],p=[];for(let t=0;t<f.length;t++)f[t]+=c;for(const s of n.patterns){if(this.patternInstruments){const n=B(e.instrumentCountMin,r,s.instruments.length);t.write(h,n-e.instrumentCountMin);for(let e=0;e<n;e++)t.write(o,s.instruments[e])}if(s.notes.length>0){t.write(1,1);let n=0;for(const r of s.notes){r.start>n&&(t.write(2,0),t.writePartDuration(r.start-n)),i.clear();for(let t=1;t<r.pitches.length;t++)i.write(1,1);r.pitches.length<e.maxChordSize&&i.write(1,0),i.writePinCount(r.pins.length-1),i.write(a,r.pins[0].size);let s=0,h=r.pitches[0],o=h;const l=[];for(let t=1;t<r.pins.length;t++){const e=r.pins[t],n=h+e.interval;o!=n?(i.write(1,1),l.push(n),o=n):i.write(1,0),i.writePartDuration(e.time-s),s=e.time,i.write(a,e.size)}const c=String.fromCharCode.apply(null,i.encodeBase64([])),d=p.indexOf(c);-1==d?(t.write(2,1),t.concat(i)):(t.write(1,1),t.writeLongTail(0,0,d),p.splice(d,1)),p.unshift(c),p.length>10&&p.pop();const m=r.pitches.concat(l);for(let e=0;e<m.length;e++){const s=m[e],n=f.indexOf(s);if(-1==n){let e=0,n=u;if(n<s)for(;n!=s;)n++,-1==f.indexOf(n)&&e++;else for(;n!=s;)n--,-1==f.indexOf(n)&&e--;t.write(1,0),t.writePitchInterval(e)}else t.write(1,1),t.write(3,n),f.splice(n,1);f.unshift(s),f.length>8&&f.pop(),u=e==r.pitches.length-1?r.pitches[0]:s}0==r.start&&t.write(1,r.continuesLastPattern?1:0),n=r.end}n<this.beatsPerBar*e.partsPerBeat&&(t.write(2,0),t.writePartDuration(this.beatsPerBar*e.partsPerBeat-n))}else t.write(1,0)}}let r=t.lengthBase64(),h=[];for(;r>0;)h.unshift(w[63&r]),r>>=6;s.push(w[h.length]),Array.prototype.push.apply(s,h),t.encodeBase64(s);const o=64e3;if(s.length<o)return String.fromCharCode.apply(null,s);{let t="";for(let e=0;e<s.length;e+=o)t+=String.fromCharCode.apply(null,s.slice(e,e+o));return t}}static L(t){return 0==t?t=1:1==t&&(t=0),e.envelopes[E(0,e.envelopes.length,t)]}fromBase64String(t){if(null==t||""==t)return void this.initToDefault(!0);let s=0;for(;t.charCodeAt(s)<=32;)s++;if(35==t.charCodeAt(s)&&s++,123==t.charCodeAt(s))return void this.fromJsonObject(JSON.parse(0==s?t:t.substring(s)));const n=k[t.charCodeAt(s++)];if(-1==n||n>K.P||n<K.T)return;const i=n<3,a=n<4,r=n<5,h=n<6,o=n<7,v=n<8,I=n<9;if(this.initToDefault(I),i){for(const t of this.channels)t.instruments[0].transition=e.transitions.dictionary.interrupt.index,t.instruments[0].effects|=1024;this.channels[3].instruments[0].chipNoise=0}let P=null;if(I){P=[];for(let t=P.length;t<this.getChannelCount();t++){P[t]=[];for(let s=0;s<e.instrumentCountMin;s++)P[t][s]={}}}let D,F=0,x=0,L=-1;for(;s<t.length;)switch(D=t.charCodeAt(s++)){case 110:this.pitchChannelCount=k[t.charCodeAt(s++)],this.noiseChannelCount=k[t.charCodeAt(s++)],this.pitchChannelCount=B(e.pitchChannelCountMin,e.pitchChannelCountMax,this.pitchChannelCount),this.noiseChannelCount=B(e.noiseChannelCountMin,e.noiseChannelCountMax,this.noiseChannelCount);for(let t=this.channels.length;t<this.getChannelCount();t++)this.channels[t]=new j;if(this.channels.length=this.getChannelCount(),I)for(let t=P.length;t<this.getChannelCount();t++){P[t]=[];for(let s=0;s<e.instrumentCountMin;s++)P[t][s]={}}break;case 115:this.scale=k[t.charCodeAt(s++)],i&&10==this.scale&&(this.scale=11);break;case 107:this.key=E(0,e.keys.length,o?11-k[t.charCodeAt(s++)]:k[t.charCodeAt(s++)]);break;case 108:this.loopStart=r?k[t.charCodeAt(s++)]:(k[t.charCodeAt(s++)]<<6)+k[t.charCodeAt(s++)];break;case 101:this.loopLength=r?k[t.charCodeAt(s++)]:(k[t.charCodeAt(s++)]<<6)+k[t.charCodeAt(s++)]+1;break;case 116:this.tempo=a?[95,120,151,190][k[t.charCodeAt(s++)]]:o?[88,95,103,111,120,130,140,151,163,176,190,206,222,240,259][k[t.charCodeAt(s++)]]:k[t.charCodeAt(s++)]<<6|k[t.charCodeAt(s++)],this.tempo=E(e.tempoMin,e.tempoMax+1,this.tempo);break;case 109:I&&(F=k[t.charCodeAt(s++)],F=E(0,4,F));break;case 97:this.beatsPerBar=i?[6,7,8,9,10][k[t.charCodeAt(s++)]]:k[t.charCodeAt(s++)]+1,this.beatsPerBar=Math.max(e.beatsPerBarMin,Math.min(e.beatsPerBarMax,this.beatsPerBar));break;case 103:{const n=(k[t.charCodeAt(s++)]<<6)+k[t.charCodeAt(s++)]+1;this.barCount=B(e.barCountMin,e.barCountMax,n);for(let t=0;t<this.getChannelCount();t++){for(let e=this.channels[t].bars.length;e<this.barCount;e++)this.channels[t].bars[e]=1;this.channels[t].bars.length=this.barCount}}break;case 106:{let n;n=v?k[t.charCodeAt(s++)]+1:(k[t.charCodeAt(s++)]<<6)+k[t.charCodeAt(s++)]+1,this.patternsPerChannel=B(1,e.barCountMax,n);const i=this.getChannelCount();for(let t=0;t<i;t++){const e=this.channels[t].patterns;for(let t=e.length;t<this.patternsPerChannel;t++)e[t]=new N;e.length=this.patternsPerChannel}}break;case 105:if(I){const n=B(e.instrumentCountMin,e.patternInstrumentCountMax,k[t.charCodeAt(s++)]+e.instrumentCountMin);this.layeredInstruments=!1,this.patternInstruments=n>1;for(let t=0;t<this.getChannelCount();t++){const e=t>=this.pitchChannelCount;for(let s=this.channels[t].instruments.length;s<n;s++)this.channels[t].instruments[s]=new H(e);if(this.channels[t].instruments.length=n,h)for(let s=0;s<n;s++)this.channels[t].instruments[s].setTypeAndReset(e?2:0,e);for(let e=P[t].length;e<n;e++)P[t][e]={}}}else{const n=k[t.charCodeAt(s++)];this.layeredInstruments=0!=(2&n),this.patternInstruments=0!=(1&n);for(let n=0;n<this.getChannelCount();n++){let i=1;(this.layeredInstruments||this.patternInstruments)&&(i=B(e.instrumentCountMin,this.getMaxInstrumentsPerChannel(),k[t.charCodeAt(s++)]+e.instrumentCountMin));const a=this.channels[n],r=this.getChannelIsNoise(n);for(let t=a.instruments.length;t<i;t++)a.instruments[t]=new H(r);a.instruments.length=i}}break;case 114:this.rhythm=k[t.charCodeAt(s++)];break;case 111:if(i){const n=k[t.charCodeAt(s++)];this.channels[n].octave=E(0,e.pitchOctaves,k[t.charCodeAt(s++)]+1),n>=this.pitchChannelCount&&(this.channels[n].octave=0)}else if(I)for(let n=0;n<this.getChannelCount();n++)this.channels[n].octave=E(0,e.pitchOctaves,k[t.charCodeAt(s++)]+1),n>=this.pitchChannelCount&&(this.channels[n].octave=0);else for(let n=0;n<this.pitchChannelCount;n++)this.channels[n].octave=E(0,e.pitchOctaves,k[t.charCodeAt(s++)]);break;case 84:{L++,L>=this.channels[x].instruments.length&&(x++,L=0),B(0,this.channels.length-1,x);const n=this.channels[x].instruments[L],i=B(0,7,k[t.charCodeAt(s++)]);n.setTypeAndReset(i,x>=this.pitchChannelCount),o&&(n.effects=0,F>0&&!this.getChannelIsNoise(x)&&(n.reverb=F,n.effects|=1),n.chord!=e.chords.dictionary.simultaneous.index&&(n.effects|=2048))}break;case 117:{const e=k[t.charCodeAt(s++)]<<6|k[t.charCodeAt(s++)];this.channels[x].instruments[L].preset=e}break;case 119:if(i){const n=[1,2,3,4,5,6,7,8,0],i=k[t.charCodeAt(s++)],a=this.channels[i].instruments[0];a.chipWave=E(0,e.chipWaves.length,0|n[k[t.charCodeAt(s++)]]),a.convertLegacySettings(P[i][0])}else if(h){const n=[1,2,3,4,5,6,7,8,0];for(let i=0;i<this.getChannelCount();i++)for(const a of this.channels[i].instruments)i>=this.pitchChannelCount?a.chipNoise=E(0,e.chipNoises.length,k[t.charCodeAt(s++)]):a.chipWave=E(0,e.chipWaves.length,0|n[k[t.charCodeAt(s++)]])}else if(o){const n=[1,2,3,4,5,6,7,8,0];x>=this.pitchChannelCount?this.channels[x].instruments[L].chipNoise=E(0,e.chipNoises.length,k[t.charCodeAt(s++)]):this.channels[x].instruments[L].chipWave=E(0,e.chipWaves.length,0|n[k[t.charCodeAt(s++)]])}else x>=this.pitchChannelCount?this.channels[x].instruments[L].chipNoise=E(0,e.chipNoises.length,k[t.charCodeAt(s++)]):this.channels[x].instruments[L].chipWave=E(0,e.chipWaves.length,k[t.charCodeAt(s++)]);break;case 102:if(I)if(o){const n=[10,6,3,0,8,5,2],a=["none","none","none","none","decay 1","decay 2","decay 3"];if(i){const i=k[t.charCodeAt(s++)],r=this.channels[i].instruments[0],h=P[i][0],o=[1,3,4,5][E(0,n.length,k[t.charCodeAt(s++)])];h.filterCutoff=n[o],h.filterResonance=0,h.filterEnvelope=e.envelopes.dictionary[a[o]],r.convertLegacySettings(h)}else if(h)for(let i=0;i<this.getChannelCount();i++)for(let r=0;r<this.channels[i].instruments.length;r++){const h=this.channels[i].instruments[r],o=P[i][r],l=E(0,n.length,k[t.charCodeAt(s++)]+1);i<this.pitchChannelCount?(o.filterCutoff=n[l],o.filterResonance=0,o.filterEnvelope=e.envelopes.dictionary[a[l]]):(o.filterCutoff=10,o.filterResonance=0,o.filterEnvelope=e.envelopes.dictionary.none),h.convertLegacySettings(o)}else{const e=E(0,n.length,k[t.charCodeAt(s++)]),i=this.channels[x].instruments[L],a=P[x][L];a.filterCutoff=n[e],a.filterResonance=0,i.convertLegacySettings(a)}}else{const e=11,n=this.channels[x].instruments[L],i=P[x][L];i.filterCutoff=E(0,e,k[t.charCodeAt(s++)]),n.convertLegacySettings(i)}else{const n=this.channels[x].instruments[L],i=k[t.charCodeAt(s++)];n.eqFilter.controlPointCount=E(0,e.filterMaxPoints+1,i);for(let t=n.eqFilter.controlPoints.length;t<n.eqFilter.controlPointCount;t++)n.eqFilter.controlPoints[t]=new q;for(let i=0;i<n.eqFilter.controlPointCount;i++){const a=n.eqFilter.controlPoints[i];a.type=E(0,3,k[t.charCodeAt(s++)]),a.freq=E(0,e.filterFreqRange,k[t.charCodeAt(s++)]),a.gain=E(0,e.filterGainRange,k[t.charCodeAt(s++)])}for(let t=n.eqFilter.controlPointCount;t<i;t++)s+=3}break;case 121:if(I){const e=8,n=this.channels[x].instruments[L],i=P[x][L];i.filterResonance=E(0,e,k[t.charCodeAt(s++)]),n.convertLegacySettings(i)}break;case 122:{const n=this.channels[x].instruments[L];if(I)if(4==n.type)for(let i=0;i<e.drumCount;i++)n.drumsetEnvelopes[i]=K.L(k[t.charCodeAt(s++)]).index;else{const e=P[x][L];e.filterEnvelope=K.L(k[t.charCodeAt(s++)]),n.convertLegacySettings(e)}else for(let i=0;i<e.drumCount;i++)n.drumsetEnvelopes[i]=E(0,e.envelopes.length,k[t.charCodeAt(s++)])}break;case 87:{const n=this.channels[x].instruments[L];if(n.pulseWidth=E(0,e.pulseWidthRange,k[t.charCodeAt(s++)]),I){const e=P[x][L];e.pulseEnvelope=K.L(k[t.charCodeAt(s++)]),n.convertLegacySettings(e)}}break;case 73:this.channels[x].instruments[L].stringSustain=E(0,e.stringSustainRange,k[t.charCodeAt(s++)]);break;case 100:if(I){const n=[{transition:"interrupt",fadeInSeconds:0,fadeOutTicks:-1},{transition:"normal",fadeInSeconds:0,fadeOutTicks:-3},{transition:"normal",fadeInSeconds:.025,fadeOutTicks:-3},{transition:"slide in pattern",fadeInSeconds:.025,fadeOutTicks:-3},{transition:"normal",fadeInSeconds:.04,fadeOutTicks:6},{transition:"normal",fadeInSeconds:0,fadeOutTicks:48},{transition:"normal",fadeInSeconds:.0125,fadeOutTicks:72},{transition:"normal",fadeInSeconds:.06,fadeOutTicks:96}];if(i){const i=k[t.charCodeAt(s++)],a=n[E(0,n.length,k[t.charCodeAt(s++)])],r=this.channels[i].instruments[0];r.fadeIn=X.secondsToFadeInSetting(a.fadeInSeconds),r.fadeOut=X.ticksToFadeOutSetting(a.fadeOutTicks),r.transition=e.transitions.dictionary[a.transition].index,r.transition!=e.transitions.dictionary.normal.index&&(r.effects|=1024)}else if(h)for(let i=0;i<this.getChannelCount();i++)for(const a of this.channels[i].instruments){const i=n[E(0,n.length,k[t.charCodeAt(s++)])];a.fadeIn=X.secondsToFadeInSetting(i.fadeInSeconds),a.fadeOut=X.ticksToFadeOutSetting(i.fadeOutTicks),a.transition=e.transitions.dictionary[i.transition].index,a.transition!=e.transitions.dictionary.normal.index&&(a.effects|=1024)}else{const i=n[E(0,n.length,k[t.charCodeAt(s++)])],a=this.channels[x].instruments[L];a.fadeIn=X.secondsToFadeInSetting(i.fadeInSeconds),a.fadeOut=X.ticksToFadeOutSetting(i.fadeOutTicks),a.transition=e.transitions.dictionary[i.transition].index,a.transition!=e.transitions.dictionary.normal.index&&(a.effects|=1024)}}else{const n=this.channels[x].instruments[L];n.fadeIn=E(0,e.fadeInRange,k[t.charCodeAt(s++)]),n.fadeOut=E(0,e.fadeOutTicks.length,k[t.charCodeAt(s++)])}break;case 99:if(I)if(o)if(i){const n=[0,3,2,0],i=["none","none","none","tremolo2"],a=k[t.charCodeAt(s++)],r=E(0,n.length,k[t.charCodeAt(s++)]),h=this.channels[a].instruments[0],o=P[a][0];h.vibrato=n[r],null!=o.filterEnvelope&&1!=o.filterEnvelope.type||(o.filterEnvelope=e.envelopes.dictionary[i[r]],h.convertLegacySettings(o)),h.vibrato!=e.vibratos.dictionary.none.index&&(h.effects|=512)}else if(h){const n=[0,1,2,3,0,0],i=["none","none","none","none","tremolo5","tremolo2"];for(let a=0;a<this.getChannelCount();a++)for(let r=0;r<this.channels[a].instruments.length;r++){const h=E(0,n.length,k[t.charCodeAt(s++)]),o=this.channels[a].instruments[r],l=P[a][r];o.vibrato=n[h],null!=l.filterEnvelope&&1!=l.filterEnvelope.type||(l.filterEnvelope=e.envelopes.dictionary[i[h]],o.convertLegacySettings(l)),o.vibrato!=e.vibratos.dictionary.none.index&&(o.effects|=512),0==F||this.getChannelIsNoise(a)||(o.effects|=1,o.reverb=F)}}else{const n=[0,1,2,3,0,0],i=["none","none","none","none","tremolo5","tremolo2"],a=E(0,n.length,k[t.charCodeAt(s++)]),r=this.channels[x].instruments[L],h=P[x][L];r.vibrato=n[a],null!=h.filterEnvelope&&1!=h.filterEnvelope.type||(h.filterEnvelope=e.envelopes.dictionary[i[a]],r.convertLegacySettings(h)),r.vibrato!=e.vibratos.dictionary.none.index&&(r.effects|=512),0!=F&&(r.effects|=1,r.reverb=F)}else{const n=this.channels[x].instruments[L],i=E(0,e.vibratos.length,k[t.charCodeAt(s++)]);n.vibrato=i,n.vibrato!=e.vibratos.dictionary.none.index&&(n.effects|=512)}break;case 104:if(i){const n=k[t.charCodeAt(s++)];this.channels[n].instruments[0].unison=E(0,e.unisons.length,k[t.charCodeAt(s++)])}else if(h)for(let n=0;n<this.getChannelCount();n++)for(const i of this.channels[n].instruments){const n=k[t.charCodeAt(s++)];let a=E(0,e.unisons.length,n);8==n&&(a=2,i.chord=3),i.unison=a}else if(o){const n=k[t.charCodeAt(s++)];let i=E(0,e.unisons.length,n);8==n&&(i=2,this.channels[x].instruments[L].chord=3),this.channels[x].instruments[L].unison=i}else this.channels[x].instruments[L].unison=E(0,e.unisons.length,k[t.charCodeAt(s++)]);break;case 67:if(I){const n=this.channels[x].instruments[L];n.chord=E(0,e.chords.length,k[t.charCodeAt(s++)]),n.chord!=e.chords.dictionary.simultaneous.index&&(n.effects|=2048)}break;case 113:{const n=this.channels[x].instruments[L];if(I){n.effects=4095&k[t.charCodeAt(s++)],0==F?n.effects&=-2:g(n.effects)&&(n.reverb=F),n.pan!=e.panCenter&&(n.effects|=4),n.vibrato!=e.vibratos.dictionary.none.index&&(n.effects|=4);const i=P[x][L];n.convertLegacySettings(i)}else{if(n.effects=k[t.charCodeAt(s++)]<<6|k[t.charCodeAt(s++)],d(n.effects)){const i=k[t.charCodeAt(s++)];n.noteFilter.controlPointCount=E(0,e.filterMaxPoints+1,i);for(let t=n.noteFilter.controlPoints.length;t<n.noteFilter.controlPointCount;t++)n.noteFilter.controlPoints[t]=new q;for(let i=0;i<n.noteFilter.controlPointCount;i++){const a=n.noteFilter.controlPoints[i];a.type=E(0,3,k[t.charCodeAt(s++)]),a.freq=E(0,e.filterFreqRange,k[t.charCodeAt(s++)]),a.gain=E(0,e.filterGainRange,k[t.charCodeAt(s++)])}for(let t=n.noteFilter.controlPointCount;t<i;t++)s+=3}l(n.effects)&&(n.transition=E(0,e.transitions.length,k[t.charCodeAt(s++)])),c(n.effects)&&(n.chord=E(0,e.chords.length,k[t.charCodeAt(s++)])),u(n.effects)&&(n.pitchShift=E(0,e.pitchShiftRange,k[t.charCodeAt(s++)])),f(n.effects)&&(n.detune=E(0,e.detuneMax+1,k[t.charCodeAt(s++)])),p(n.effects)&&(n.vibrato=E(0,e.vibratos.length,k[t.charCodeAt(s++)])),m(n.effects)&&(n.distortion=E(0,e.distortionRange,k[t.charCodeAt(s++)])),S(n.effects)&&(n.bitcrusherFreq=E(0,e.bitcrusherFreqRange,k[t.charCodeAt(s++)]),n.bitcrusherQuantization=E(0,e.bitcrusherQuantizationRange,k[t.charCodeAt(s++)])),y(n.effects)&&(n.pan=E(0,e.panMax+1,k[t.charCodeAt(s++)])),b(n.effects)&&(n.chorus=E(0,e.chorusRange,k[t.charCodeAt(s++)])),M(n.effects)&&(n.echoSustain=E(0,e.echoSustainRange,k[t.charCodeAt(s++)]),n.echoDelay=E(0,e.echoDelayRange,k[t.charCodeAt(s++)])),g(n.effects)&&(n.reverb=E(0,e.reverbRange,k[t.charCodeAt(s++)]))}n.effects&=4095}break;case 118:if(i){const n=k[t.charCodeAt(s++)],i=this.channels[n].instruments[0];i.volume=E(0,e.volumeRange,k[t.charCodeAt(s++)]),5==i.volume&&(i.volume=e.volumeRange-1)}else if(h)for(let n=0;n<this.getChannelCount();n++)for(const i of this.channels[n].instruments)i.volume=E(0,e.volumeRange,k[t.charCodeAt(s++)]),5==i.volume&&(i.volume=e.volumeRange-1);else if(o){const n=this.channels[x].instruments[L];n.volume=E(0,e.volumeRange,k[t.charCodeAt(s++)]),5==n.volume&&(n.volume=e.volumeRange-1)}else{this.channels[x].instruments[L].volume=E(0,e.volumeRange,k[t.charCodeAt(s++)])}break;case 76:if(I){this.channels[x].instruments[L].pan=E(0,e.panMax+1,k[t.charCodeAt(s++)])}break;case 65:{const n=this.channels[x].instruments[L];if(n.algorithm=E(0,e.algorithms.length,k[t.charCodeAt(s++)]),I){const t=P[x][L];n.convertLegacySettings(t)}}break;case 70:this.channels[x].instruments[L].feedbackType=E(0,e.feedbacks.length,k[t.charCodeAt(s++)]);break;case 66:this.channels[x].instruments[L].feedbackAmplitude=E(0,e.operatorAmplitudeMax+1,k[t.charCodeAt(s++)]);break;case 86:if(I){const e=this.channels[x].instruments[L],n=P[x][L];n.feedbackEnvelope=K.L(k[t.charCodeAt(s++)]),e.convertLegacySettings(n)}break;case 81:for(let n=0;n<e.operatorCount;n++)this.channels[x].instruments[L].operators[n].frequency=E(0,e.operatorFrequencies.length,k[t.charCodeAt(s++)]);break;case 80:for(let n=0;n<e.operatorCount;n++)this.channels[x].instruments[L].operators[n].amplitude=E(0,e.operatorAmplitudeMax+1,k[t.charCodeAt(s++)]);break;case 69:{const n=this.channels[x].instruments[L];if(I){const i=P[x][L];i.operatorEnvelopes=[];for(let n=0;n<e.operatorCount;n++)i.operatorEnvelopes[n]=K.L(k[t.charCodeAt(s++)]);n.convertLegacySettings(i)}else{const i=E(0,e.maxEnvelopeCount+1,k[t.charCodeAt(s++)]);for(let a=0;a<i;a++){const i=E(0,e.instrumentAutomationTargets.length,k[t.charCodeAt(s++)]);let a=0;const r=e.instrumentAutomationTargets[i].maxCount;r>1&&(a=E(0,r,k[t.charCodeAt(s++)]));const h=E(0,e.envelopes.length,k[t.charCodeAt(s++)]);n.addEnvelope(i,a,h)}}}break;case 83:{const n=this.channels[x].instruments[L];if(3==n.type){const i=Math.ceil(e.spectrumControlPoints*e.spectrumControlPointBits/6),a=new O(t,s,s+i);for(let t=0;t<e.spectrumControlPoints;t++)n.spectrumWave.spectrum[t]=a.read(e.spectrumControlPointBits);n.spectrumWave.markCustomWaveDirty(),s+=i}else{if(4!=n.type)throw new Error("Unhandled instrument type for spectrum song tag code.");{const i=Math.ceil(e.drumCount*e.spectrumControlPoints*e.spectrumControlPointBits/6),a=new O(t,s,s+i);for(let t=0;t<e.drumCount;t++){for(let s=0;s<e.spectrumControlPoints;s++)n.drumsetSpectrumWaves[t].spectrum[s]=a.read(e.spectrumControlPointBits);n.drumsetSpectrumWaves[t].markCustomWaveDirty()}s+=i}}}break;case 72:{const n=this.channels[x].instruments[L],i=Math.ceil(e.harmonicsControlPoints*e.harmonicsControlPointBits/6),a=new O(t,s,s+i);for(let t=0;t<e.harmonicsControlPoints;t++)n.harmonicsWave.harmonics[t]=a.read(e.harmonicsControlPointBits);n.harmonicsWave.markCustomWaveDirty(),s+=i}break;case 98:{let e;if(i){const n=k[t.charCodeAt(s++)],i=k[t.charCodeAt(s++)];e=Math.ceil(.5*i);const a=new O(t,s,s+e);for(let t=0;t<i;t++)this.channels[n].bars[t]=a.read(3)+1}else if(r){let n=0;for(;1<<n<this.patternsPerChannel;)n++;e=Math.ceil(this.getChannelCount()*this.barCount*n/6);const i=new O(t,s,s+e);for(let t=0;t<this.getChannelCount();t++)for(let e=0;e<this.barCount;e++)this.channels[t].bars[e]=i.read(n)+1}else{let n=0;for(;1<<n<this.patternsPerChannel+1;)n++;e=Math.ceil(this.getChannelCount()*this.barCount*n/6);const i=new O(t,s,s+e);for(let t=0;t<this.getChannelCount();t++)for(let e=0;e<this.barCount;e++)this.channels[t].bars[e]=i.read(n)}s+=e}break;case 112:{let n,a=0;if(i)n=k[t.charCodeAt(s++)],s++,a=k[t.charCodeAt(s++)],a<<=6,a+=k[t.charCodeAt(s++)];else{n=0;let e=B(1,4,k[t.charCodeAt(s++)]);for(;e>0;)a<<=6,a+=k[t.charCodeAt(s++)],e--}const r=new O(t,s,s+a);s+=a;const h=K.getNeededBits(e.noteSizeMax);for(;;){const t=this.channels[n],s=this.getChannelIsNoise(n),a=this.getMaxInstrumentsPerPattern(n),l=K.getNeededBits(a-e.instrumentCountMin),c=K.getNeededBits(t.instruments.length-1),u=s?0:12*t.octave;let f=s?4:u;const p=s?[4,6,7,2,3,8,0,10]:[0,7,12,19,24,-5,-12],d=[];for(let t=0;t<p.length;t++)p[t]+=u;for(let s=0;s<this.patternsPerChannel;s++){const n=t.patterns[s];if(I)n.instruments[0]=B(0,t.instruments.length-1,r.read(c)),n.instruments.length=1;else if(this.patternInstruments){const s=B(e.instrumentCountMin,a,r.read(l)+e.instrumentCountMin);for(let e=0;e<s;e++)n.instruments[e]=B(0,t.instruments.length-1,r.read(c));n.instruments.length=s}else n.instruments[0]=0,n.instruments.length=e.instrumentCountMin;if(!i&&0==r.read(1)){n.notes.length=0;continue}let u=0;const m=n.notes;let S=0;for(;u<this.beatsPerBar*e.partsPerBeat;){const t=1==r.read(1);let s=!1,n=0;if(t?n=B(0,d.length-1,r.readLongTail(0,0)):s=1==r.read(1),t||s){let s,i,a;if(t)s=d[n],d.splice(n,1);else{for(s={},s.pitchCount=1;s.pitchCount<e.maxChordSize&&1==r.read(1);)s.pitchCount++;s.pinCount=r.readPinCount(),s.initialSize=r.read(h),s.pins=[],s.length=0,s.bendCount=0;for(let t=0;t<s.pinCount;t++){let t={};t.pitchBend=1==r.read(1),t.pitchBend&&s.bendCount++,s.length+=o?r.readLegacyPartDuration()*e.partsPerBeat/e.rhythms[this.rhythm].stepsPerBeat:r.readPartDuration(),t.time=s.length,t.size=r.read(h),s.pins.push(t)}}d.unshift(s),d.length>10&&d.pop(),m.length<=S?(i=new A(0,u,u+s.length,s.initialSize),m[S++]=i):(i=m[S++],i.start=u,i.end=u+s.length,i.pins[0].size=s.initialSize);let l=0;const c=[];for(let t=0;t<s.pitchCount+s.bendCount;t++){if(1==r.read(1)){const t=B(0,p.length-1,r.read(3));a=p[t],p.splice(t,1)}else{const t=r.readPitchInterval();a=f;let e=t;for(;e>0;){for(a++;-1!=p.indexOf(a);)a++;e--}for(;e<0;){for(a--;-1!=p.indexOf(a);)a--;e++}}p.unshift(a),p.length>8&&p.pop(),t<s.pitchCount?i.pitches[l++]=a:c.push(a),f=t==s.pitchCount-1?i.pitches[0]:a}i.pitches.length=l,c.unshift(i.pitches[0]);let y=1;for(const t of s.pins){t.pitchBend&&c.shift();const e=c[0]-i.pitches[0];if(i.pins.length<=y)i.pins[y++]=C(e,t.time,t.size);else{const s=i.pins[y++];s.interval=e,s.time=t.time,s.size=t.size}}i.pins.length=y,0!=i.start||I?i.continuesLastPattern=!1:i.continuesLastPattern=1==r.read(1),u=B(0,this.beatsPerBar*e.partsPerBeat,i.end)}else{u+=o?r.readLegacyPartDuration()*e.partsPerBeat/e.rhythms[this.rhythm].stepsPerBeat:r.readPartDuration()}}m.length=S}if(i)break;if(n++,n>=this.getChannelCount())break}}break;default:throw new Error("Unrecognized song tag code "+String.fromCharCode(D)+" at index "+(s-1))}}toJsonObject(t=!0,s=1,n=!0){const i=[];for(let a=0;a<this.getChannelCount();a++){const r=this.channels[a],h=[],o=this.getChannelIsNoise(a);for(const t of r.instruments)h.push(t.toJsonObject());const l=[];for(const t of r.patterns){const s=[];for(const n of t.notes){const t=[];for(const s of n.pins)t.push({tick:(s.time+n.start)*e.rhythms[this.rhythm].stepsPerBeat/e.partsPerBeat,pitchBend:s.interval,volume:Math.round(100*s.size/3)});const i={pitches:n.pitches,points:t};0==n.start&&(i.continuesLastPattern=n.continuesLastPattern),s.push(i)}const n={notes:s};this.patternInstruments&&(n.instruments=t.instruments.map((t=>t+1))),l.push(n)}const c=[];if(t)for(let t=0;t<this.loopStart;t++)c.push(r.bars[t]);for(let t=0;t<s;t++)for(let t=this.loopStart;t<this.loopStart+this.loopLength;t++)c.push(r.bars[t]);if(n)for(let t=this.loopStart+this.loopLength;t<this.barCount;t++)c.push(r.bars[t]);const u={type:o?"drum":"pitch",instruments:h,patterns:l,sequence:c};o||(u.octaveScrollBar=r.octave-1),i.push(u)}return{format:K.k,version:K.P,scale:e.scales[this.scale].name,key:e.keys[this.key].name,introBars:this.loopStart,loopBars:this.loopLength,beatsPerBar:this.beatsPerBar,ticksPerBeat:e.rhythms[this.rhythm].stepsPerBeat,beatsPerMinute:this.tempo,layeredInstruments:this.layeredInstruments,patternInstruments:this.patternInstruments,channels:i}}fromJsonObject(t){if(this.initToDefault(!0),!t)return;if(this.scale=11,null!=t.scale){const s={"romani :)":"dbl harmonic :)","romani :(":"dbl harmonic :(",enigma:"strange"},n=null!=s[t.scale]?s[t.scale]:t.scale,i=e.scales.findIndex((t=>t.name==n));-1!=i&&(this.scale=i)}if(null!=t.key)if("number"==typeof t.key)this.key=(t.key+1200>>>0)%e.keys.length;else if("string"==typeof t.key){const e=t.key,s=e.charAt(0).toUpperCase(),n=e.charAt(1).toLowerCase();let i={C:0,D:2,E:4,F:5,G:7,A:9,B:11}[s];const a={"#":1,"♯":1,b:-1,"♭":-1}[n];null!=i&&(null!=a&&(i+=a),i<0&&(i+=12),i%=12,this.key=i)}null!=t.beatsPerMinute&&(this.tempo=E(e.tempoMin,e.tempoMax+1,0|t.beatsPerMinute));let s=0;null!=t.reverb&&(s=E(0,4,0|t.reverb)),null!=t.beatsPerBar&&(this.beatsPerBar=Math.max(e.beatsPerBarMin,Math.min(e.beatsPerBarMax,0|t.beatsPerBar)));let n=4;null!=t.ticksPerBeat&&(n=0|t.ticksPerBeat||4,this.rhythm=e.rhythms.findIndex((t=>t.stepsPerBeat==n)),-1==this.rhythm&&(this.rhythm=1));let i=1,a=1,r=1;if(null!=t.channels)for(const e of t.channels)e.instruments&&(i=Math.max(i,0|e.instruments.length)),e.patterns&&(a=Math.max(a,0|e.patterns.length)),e.sequence&&(r=Math.max(r,0|e.sequence.length));null!=t.layeredInstruments?this.layeredInstruments=!!t.layeredInstruments:this.layeredInstruments=!1,null!=t.patternInstruments?this.patternInstruments=!!t.patternInstruments:this.patternInstruments=i>1,this.patternsPerChannel=Math.min(a,e.barCountMax),this.barCount=Math.min(r,e.barCountMax),null!=t.introBars&&(this.loopStart=E(0,this.barCount,0|t.introBars)),null!=t.loopBars&&(this.loopLength=E(1,this.barCount-this.loopStart+1,0|t.loopBars));const h=[],o=[];if(null!=t.channels)for(let i=0;i<t.channels.length;i++){let a=t.channels[i];const r=new j;let l=!1;if(l=null!=a.type?"drum"==a.type:i>=3,l?o.push(r):h.push(r),null!=a.octaveScrollBar&&(r.octave=E(0,e.pitchOctaves,1+(0|a.octaveScrollBar)),l&&(r.octave=0)),Array.isArray(a.instruments)){const t=a.instruments;for(let e=0;e<t.length&&!(e>=this.getMaxInstrumentsPerChannel());e++){const n=new H(l);r.instruments[e]=n,n.fromJsonObject(t[e],l,s)}}for(let t=0;t<this.patternsPerChannel;t++){const s=new N;let i;if(r.patterns[t]=s,a.patterns&&(i=a.patterns[t]),null!=i){if(this.patternInstruments)if(Array.isArray(i.instruments)){const t=i.instruments,n=E(e.instrumentCountMin,this.getMaxInstrumentsPerPatternForChannel(r)+1,t.length);for(let e=0;e<n;e++)s.instruments[e]=E(0,r.instruments.length,(0|t[e])-1);s.instruments.length=n}else s.instruments[0]=E(0,r.instruments.length,(0|i.instrument)-1),s.instruments.length=1;if(i.notes&&i.notes.length>0){const t=Math.min(this.beatsPerBar*e.partsPerBeat,i.notes.length>>>0);let a=0;for(let r=0;r<i.notes.length&&!(r>=t);r++){const t=i.notes[r];if(!(t&&t.pitches&&t.pitches.length>=1&&t.points&&t.points.length>=2))continue;const h=new A(0,0,0,0);h.pitches=[],h.pins=[];for(let s=0;s<t.pitches.length;s++){const n=0|t.pitches[s];if(-1==h.pitches.indexOf(n)&&(h.pitches.push(n),h.pitches.length>=e.maxChordSize))break}if(h.pitches.length<1)continue;let o=a,c=0;for(let s=0;s<t.points.length;s++){const i=t.points[s];if(null==i||null==i.tick)continue;const a=null==i.pitchBend?0:0|i.pitchBend,r=Math.round(+i.tick*e.partsPerBeat/n),l=null==i.volume?3:Math.max(0,Math.min(3,Math.round(3*(0|i.volume)/100)));if(!(r>this.beatsPerBar*e.partsPerBeat)){if(0==h.pins.length){if(r<o)continue;h.start=r,c=a}else if(r<=o)continue;o=r,h.pins.push(C(a-c,r-h.start,l))}}if(h.pins.length<2)continue;h.end=h.pins[h.pins.length-1].time+h.start;const u=l?e.drumCount-1:e.maxPitch;let f=u,p=0;for(let t=0;t<h.pitches.length;t++)h.pitches[t]+=c,(h.pitches[t]<0||h.pitches[t]>u)&&(h.pitches.splice(t,1),t--),h.pitches[t]<f&&(f=h.pitches[t]),h.pitches[t]>p&&(p=h.pitches[t]);if(!(h.pitches.length<1)){for(let t=0;t<h.pins.length;t++){const e=h.pins[t];e.interval+f<0&&(e.interval=-f),e.interval+p>u&&(e.interval=u-p),t>=2&&e.interval==h.pins[t-1].interval&&e.interval==h.pins[t-2].interval&&e.size==h.pins[t-1].size&&e.size==h.pins[t-2].size&&(h.pins.splice(t-1,1),t--)}0==h.start?h.continuesLastPattern=!0===t.continuesLastPattern:h.continuesLastPattern=!1,s.notes.push(h),a=h.end}}}}}r.patterns.length=this.patternsPerChannel;for(let t=0;t<this.barCount;t++)r.bars[t]=null!=a.sequence?Math.min(this.patternsPerChannel,a.sequence[t]>>>0):0;r.bars.length=this.barCount}h.length>e.pitchChannelCountMax&&(h.length=e.pitchChannelCountMax),o.length>e.noiseChannelCountMax&&(o.length=e.noiseChannelCountMax),this.pitchChannelCount=h.length,this.noiseChannelCount=o.length,this.channels.length=0,Array.prototype.push.apply(this.channels,h),Array.prototype.push.apply(this.channels,o)}getPattern(t,e){if(e<0||e>=this.barCount)return null;const s=this.channels[t].bars[e];return 0==s?null:this.channels[t].patterns[s-1]}getBeatsPerMinute(){return this.tempo}static getNeededBits(t){return 32-Math.clz32(Math.ceil(t+1)-1)}}K.k="BeepBox",K.T=2,K.P=9;class J{constructor(){this.delayLine=null,this.reset()}reset(){this.delayIndex=-1,this.allPassSample=0,this.allPassPrevInput=0,this.shelfSample=0,this.shelfPrevInput=0,this.fractionalDelaySample=0,this.prevDelayLength=-1,this.delayResetOffset=0}}class Z{constructor(){this.noteSecondsStart=0,this.noteSecondsEnd=0,this.noteTicksStart=0,this.noteTicksEnd=0,this.noteSizeStart=e.noteSizeMax,this.noteSizeEnd=e.noteSizeMax,this.prevNoteSize=e.noteSizeMax,this.nextNoteSize=e.noteSizeMax,this.O=e.noteSizeMax,this.prevNoteSecondsStart=0,this.prevNoteSecondsEnd=0,this.prevNoteTicksStart=0,this.prevNoteTicksEnd=0,this.R=e.noteSizeMax,this.prevSlideStart=!1,this.prevSlideEnd=!1,this.nextSlideStart=!1,this.nextSlideEnd=!1,this.prevSlideRatioStart=0,this.prevSlideRatioEnd=0,this.nextSlideRatioStart=0,this.nextSlideRatioEnd=0,this.envelopeStarts=[],this.envelopeEnds=[],this.lowpassCutoffDecayVolumeCompensation=1;for(let t=0;t<33;t++)this.envelopeStarts[t]=1,this.envelopeEnds[t]=1;this.reset()}reset(){this.noteSecondsEnd=0,this.noteTicksEnd=0,this.O=e.noteSizeMax,this.prevNoteSecondsEnd=0,this.prevNoteTicksEnd=0,this.R=e.noteSizeMax}computeEnvelopes(t,s,n,i,a,r){const h=t.getTransition();null==r||!r.atNoteStart||h.continues||r.forceContinueAtStart||(this.prevNoteSecondsEnd=this.noteSecondsEnd,this.prevNoteTicksEnd=this.noteTicksEnd,this.R=this.O,this.noteSecondsEnd=0,this.noteTicksEnd=0),null!=r&&(null!=r.note?this.O=r.note.pins[r.note.pins.length-1].size:this.O=e.noteSizeMax);const o=i-n,l=this.noteSecondsEnd,c=l+a,u=this.noteTicksEnd,f=u+o,p=this.prevNoteSecondsEnd,d=p+a,m=this.prevNoteTicksEnd,S=m+o,y=1/(e.ticksPerPart*e.partsPerBeat),b=y*n,M=y*i;let g=this.O,v=this.O,I=this.R,P=0,D=!1,F=!1,x=!1,L=!1,T=0,w=0,k=0,O=0;if(null!=r&&null!=r.note&&!r.passedEndOfNote){const t=r.note.getEndPinIndex(s),a=r.note.pins[t-1],o=r.note.pins[t],l=(r.note.start+a.time)*e.ticksPerPart,c=(r.note.start+o.time)*e.ticksPerPart,u=(n-l)/(c-l),f=(i-l)/(c-l);if(g=a.size+(o.size-a.size)*u,v=a.size+(o.size-a.size)*f,h.slides){const t=r.noteStartPart*e.ticksPerPart,s=r.noteEndPart*e.ticksPerPart,a=.5*(s-t),o=Math.min(a,h.slideTicks);null==r.prevNote||r.forceContinueAtStart||(n-t<o&&(D=!0,T=.5*(1-(n-t)/o)),i-t<o&&(F=!0,w=.5*(1-(i-t)/o))),null==r.nextNote||r.forceContinueAtEnd||(P=r.nextNote.pins[0].size,s-n<o&&(x=!0,k=.5*(1-(s-n)/o)),s-i<o&&(L=!0,O=.5*(1-(s-i)/o)))}}let R=1,C=!1;for(let s=0;s<=t.envelopeCount;s++){let n,i,a;if(s==t.envelopeCount){if(C)break;n=e.instrumentAutomationTargets.dictionary.noteVolume,i=0,a=e.envelopes.dictionary["note size"]}else{let r=t.envelopes[s];n=e.instrumentAutomationTargets[r.target],i=r.index,a=e.envelopes[r.envelope],0==a.type&&(C=!0)}if(null!=n.computeIndex){const e=n.computeIndex+i;let s=Z.computeEnvelope(a,l,b,g),r=Z.computeEnvelope(a,c,M,v);if(D){s+=(Z.computeEnvelope(a,p,b,I)-s)*T}if(F){r+=(Z.computeEnvelope(a,d,M,I)-r)*w}if(x){s+=(Z.computeEnvelope(a,0,b,P)-s)*k}if(L){r+=(Z.computeEnvelope(a,0,M,P)-r)*O}if(this.envelopeStarts[e]*=s,this.envelopeEnds[e]*=r,n.isFilter){const e=t.noteFilter;e.controlPointCount>i&&0==e.controlPoints[i].type&&(R=Math.max(R,Z.getLowpassCutoffDecayVolumeCompensation(a)))}}}this.noteSecondsStart=l,this.noteSecondsEnd=c,this.noteTicksStart=u,this.noteTicksEnd=f,this.prevNoteSecondsStart=p,this.prevNoteSecondsEnd=d,this.prevNoteTicksStart=m,this.prevNoteTicksEnd=S,this.prevNoteSize=I,this.nextNoteSize=P,this.noteSizeStart=g,this.noteSizeEnd=v,this.prevSlideStart=D,this.prevSlideEnd=F,this.nextSlideStart=x,this.nextSlideEnd=L,this.prevSlideRatioStart=T,this.prevSlideRatioEnd=w,this.nextSlideRatioStart=k,this.nextSlideRatioEnd=O,this.lowpassCutoffDecayVolumeCompensation=R}clearEnvelopes(t){for(let s=0;s<t.envelopeCount;s++){const n=t.envelopes[s],i=e.instrumentAutomationTargets[n.target];if(null!=i.computeIndex){const t=i.computeIndex+n.index;this.envelopeStarts[t]=1,this.envelopeEnds[t]=1}}this.envelopeStarts[0]=1,this.envelopeEnds[0]=1}static computeEnvelope(t,e,s,n){switch(t.type){case 0:return X.noteSizeToVolumeMult(n);case 1:return 1;case 4:return 1/(1+e*t.speed);case 5:return 1-1/(1+e*t.speed);case 6:return.5-.5*Math.cos(2*s*Math.PI*t.speed);case 7:return.75-.25*Math.cos(2*s*Math.PI*t.speed);case 2:return Math.max(1,2-10*e);case 3:const i=.25/Math.sqrt(t.speed);return e<i?e/i:1/(1+(e-i)*t.speed);case 8:return Math.pow(2,-t.speed*e);default:throw new Error("Unrecognized operator envelope type.")}}static getLowpassCutoffDecayVolumeCompensation(t){return 8==t.type?1.25+.025*t.speed:4==t.type?1+.02*t.speed:1}}class _{constructor(){this.pitches=Array(e.maxChordSize).fill(0),this.pitchCount=0,this.chordSize=0,this.drumsetPitch=null,this.note=null,this.prevNote=null,this.nextNote=null,this.prevNotePitchIndex=0,this.nextNotePitchIndex=0,this.freshlyAllocated=!0,this.atNoteStart=!1,this.isOnLastTick=!1,this.passedEndOfNote=!1,this.forceContinueAtStart=!1,this.forceContinueAtEnd=!1,this.noteStartPart=0,this.noteEndPart=0,this.ticksSinceReleased=0,this.liveInputSamplesHeld=0,this.lastInterval=0,this.sample=0,this.phases=[],this.phaseDeltas=[],this.expressionStarts=[],this.expressionDeltas=[],this.phaseDeltaScales=[],this.prevVibrato=null,this.pulseWidth=0,this.pulseWidthDelta=0,this.pickedStrings=[],this.noteFilters=[],this.noteFilterCount=0,this.initialNoteFilterInput1=0,this.initialNoteFilterInput2=0,this.specialIntervalMult=0,this.specialIntervalExpressionMult=1,this.feedbackOutputs=[],this.feedbackMult=0,this.feedbackDelta=0,this.envelopeComputer=new Z,this.reset()}reset(){this.sample=0;const t=Math.max(e.maxChordSize,e.operatorCount);for(let e=0;e<t;e++)this.phases[e]=0,this.feedbackOutputs[e]=0;for(let t=0;t<this.noteFilterCount;t++)this.noteFilters[t].resetOutput();this.noteFilterCount=0,this.initialNoteFilterInput1=0,this.initialNoteFilterInput2=0,this.liveInputSamplesHeld=0;for(const t of this.pickedStrings)t.reset();this.envelopeComputer.reset(),this.prevVibrato=null,this.drumsetPitch=null}}class ${constructor(){this.awake=!1,this.computed=!1,this.tonesAddedInThisTick=!1,this.flushingDelayLines=!1,this.deactivateAfterThisTick=!1,this.attentuationProgress=0,this.flushedSamples=0,this.activeTones=new D,this.releasedTones=new D,this.liveInputTones=new D,this.eqFilterVolumeStart=1,this.eqFilterVolumeDelta=0,this.mixVolumeStart=1,this.mixVolumeDelta=0,this.delayInputMultStart=0,this.delayInputMultDelta=0,this.distortionStart=0,this.distortionEnd=0,this.distortionFractionalInput1=0,this.distortionFractionalInput2=0,this.distortionFractionalInput3=0,this.distortionPrevInput=0,this.distortionNextOutput=0,this.bitcrusherPrevInput=0,this.bitcrusherCurrentOutput=0,this.bitcrusherPhase=1,this.bitcrusherPhaseDelta=0,this.bitcrusherPhaseDeltaScale=1,this.bitcrusherScale=1,this.bitcrusherScaleScale=1,this.bitcrusherFoldLevel=1,this.bitcrusherFoldLevelScale=1,this.eqFilters=[],this.eqFilterCount=0,this.initialEqFilterInput1=0,this.initialEqFilterInput2=0,this.panningDelayLine=null,this.panningDelayPos=0,this.panningVolumeStartL=0,this.panningVolumeStartR=0,this.panningVolumeDeltaL=0,this.panningVolumeDeltaR=0,this.panningOffsetStartL=0,this.panningOffsetStartR=0,this.panningOffsetDeltaL=0,this.panningOffsetDeltaR=0,this.chorusDelayLineL=null,this.chorusDelayLineR=null,this.chorusDelayLineDirty=!1,this.chorusDelayPos=0,this.chorusPhase=0,this.chorusStart=0,this.chorusEnd=0,this.echoDelayLineL=null,this.echoDelayLineR=null,this.echoDelayLineDirty=!1,this.echoDelayPos=0,this.echoDelayOffsetStart=0,this.echoDelayOffsetEnd=0,this.echoDelayOffsetLastTick=0,this.echoDelayOffsetRatio=0,this.echoDelayOffsetRatioDelta=0,this.echoDelayOffsetLastTickIsComputed=!1,this.echoMultStart=0,this.echoMultDelta=0,this.echoShelfA1=0,this.echoShelfB0=0,this.echoShelfB1=0,this.echoShelfSampleL=0,this.echoShelfSampleR=0,this.echoShelfPrevInputL=0,this.echoShelfPrevInputR=0,this.reverbDelayLine=null,this.reverbDelayLineDirty=!1,this.reverbDelayPos=0,this.reverbMultStart=0,this.reverbMultDelta=0,this.reverbShelfA1=0,this.reverbShelfB0=0,this.reverbShelfB1=0,this.reverbShelfSample0=0,this.reverbShelfSample1=0,this.reverbShelfSample2=0,this.reverbShelfSample3=0,this.reverbShelfPrevInput0=0,this.reverbShelfPrevInput1=0,this.reverbShelfPrevInput2=0,this.reverbShelfPrevInput3=0}allocateNecessaryBuffers(t,s,n){if(y(s.effects)&&(null==this.panningDelayLine||this.panningDelayLine.length<t.panningDelayBufferSize)&&(this.panningDelayLine=new Float32Array(t.panningDelayBufferSize)),b(s.effects)&&((null==this.chorusDelayLineL||this.chorusDelayLineL.length<t.chorusDelayBufferSize)&&(this.chorusDelayLineL=new Float32Array(t.chorusDelayBufferSize)),(null==this.chorusDelayLineR||this.chorusDelayLineR.length<t.chorusDelayBufferSize)&&(this.chorusDelayLineR=new Float32Array(t.chorusDelayBufferSize))),M(s.effects)){const t=Math.max(e.echoDelayRange>>1,s.echoDelay+1),i=2*X.fittingPowerOfTwo(t*e.echoDelayStepTicks*n);if(null==this.echoDelayLineL||null==this.echoDelayLineR)this.echoDelayLineL=new Float32Array(i),this.echoDelayLineR=new Float32Array(i);else if(this.echoDelayLineL.length<i||this.echoDelayLineR.length<i){const t=new Float32Array(i),e=new Float32Array(i),s=this.echoDelayLineL.length-1;for(let n=0;n<this.echoDelayLineL.length;n++)t[n]=this.echoDelayLineL[this.echoDelayPos+n&s],e[n]=this.echoDelayLineL[this.echoDelayPos+n&s];this.echoDelayPos=this.echoDelayLineL.length,this.echoDelayLineL=t,this.echoDelayLineR=e}}g(s.effects)&&null==this.reverbDelayLine&&(this.reverbDelayLine=new Float32Array(e.reverbDelayBufferSize))}deactivate(){this.bitcrusherPrevInput=0,this.bitcrusherCurrentOutput=0,this.bitcrusherPhase=1;for(let t=0;t<this.eqFilterCount;t++)this.eqFilters[t].resetOutput();if(this.eqFilterCount=0,this.initialEqFilterInput1=0,this.initialEqFilterInput2=0,this.distortionFractionalInput1=0,this.distortionFractionalInput2=0,this.distortionFractionalInput3=0,this.distortionPrevInput=0,this.distortionNextOutput=0,this.panningDelayPos=0,null!=this.panningDelayLine)for(let t=0;t<this.panningDelayLine.length;t++)this.panningDelayLine[t]=0;this.echoDelayOffsetLastTickIsComputed=!1,this.echoShelfSampleL=0,this.echoShelfSampleR=0,this.echoShelfPrevInputL=0,this.echoShelfPrevInputR=0,this.reverbShelfSample0=0,this.reverbShelfSample1=0,this.reverbShelfSample2=0,this.reverbShelfSample3=0,this.reverbShelfPrevInput0=0,this.reverbShelfPrevInput1=0,this.reverbShelfPrevInput2=0,this.reverbShelfPrevInput3=0,this.awake=!1,this.flushingDelayLines=!1,this.deactivateAfterThisTick=!1,this.attentuationProgress=0,this.flushedSamples=0}resetAllEffects(){if(this.deactivate(),this.chorusDelayLineDirty){for(let t=0;t<this.chorusDelayLineL.length;t++)this.chorusDelayLineL[t]=0;for(let t=0;t<this.chorusDelayLineR.length;t++)this.chorusDelayLineR[t]=0}if(this.echoDelayLineDirty){for(let t=0;t<this.echoDelayLineL.length;t++)this.echoDelayLineL[t]=0;for(let t=0;t<this.echoDelayLineR.length;t++)this.echoDelayLineR[t]=0}if(this.reverbDelayLineDirty)for(let t=0;t<this.reverbDelayLine.length;t++)this.reverbDelayLine[t]=0;this.chorusPhase=0}compute(t,s,n,i,a){this.computed=!0,this.allocateNecessaryBuffers(t,s,n);const r=t.samplesPerSecond,h=t.tickSampleCountdown,o=h/n,l=(h-i)/n,c=m(s.effects),u=S(s.effects),f=y(s.effects),p=b(s.effects),d=M(s.effects),v=g(s.effects);if(c&&(this.distortionStart=Math.min(1,s.distortion/(e.distortionRange-1)),this.distortionEnd=Math.min(1,s.distortion/(e.distortionRange-1))),u){const n=s.bitcrusherFreq,a=s.bitcrusherFreq,h=s.bitcrusherQuantization,o=s.bitcrusherQuantization,l=e.keys[t.song.key].basePitch,c=H.frequencyFromPitch(l+60)*Math.pow(2,(e.bitcrusherFreqRange-1-n)*e.bitcrusherOctaveStep),u=H.frequencyFromPitch(l+60)*Math.pow(2,(e.bitcrusherFreqRange-1-a)*e.bitcrusherOctaveStep),f=Math.min(1,c/r),p=Math.min(1,u/r);this.bitcrusherPhaseDelta=f,this.bitcrusherPhaseDeltaScale=Math.pow(p/f,1/i);const d=2*e.bitcrusherBaseVolume*Math.pow(2,1-Math.pow(2,.5*(e.bitcrusherQuantizationRange-1-h))),m=2*e.bitcrusherBaseVolume*Math.pow(2,1-Math.pow(2,.5*(e.bitcrusherQuantizationRange-1-o)));this.bitcrusherScale=d,this.bitcrusherScaleScale=Math.pow(m/d,1/i);const S=2*e.bitcrusherBaseVolume*Math.pow(1.5,e.bitcrusherQuantizationRange-1-h),y=2*e.bitcrusherBaseVolume*Math.pow(1.5,e.bitcrusherQuantizationRange-1-o);this.bitcrusherFoldLevel=S,this.bitcrusherFoldLevelScale=Math.pow(y/S,1/i)}let I=1;const P=s.eqFilter;for(let t=0;t<P.controlPointCount;t++){const e=P.controlPoints[t];e.toCoefficients(X.tempFilterStartCoefficients,r,1,1),e.toCoefficients(X.tempFilterEndCoefficients,r,1,1),this.eqFilters.length<=t&&(this.eqFilters[t]=new L),this.eqFilters[t].loadCoefficientsWithGradient(X.tempFilterStartCoefficients,X.tempFilterEndCoefficients,1/i,0==e.type),I*=e.getVolumeCompensationMult()}this.eqFilterCount=P.controlPointCount,I=Math.min(3,I);const D=X.instrumentVolumeToVolumeMult(s.volume);this.mixVolumeStart=D;const F=D;this.mixVolumeDelta=(F-this.mixVolumeStart)/i;let x=I,T=I,w=1,k=1;if(f){const t=(s.pan-e.panCenter)/e.panCenter,n=Math.max(-1,Math.min(1,t)),a=Math.max(-1,Math.min(1,t)),h=1.414*Math.cos((1+n)*Math.PI*.25),o=1.414*Math.cos((1-n)*Math.PI*.25),l=1.414*Math.cos((1+a)*Math.PI*.25),c=1.414*Math.cos((1-a)*Math.PI*.25),u=r*e.panDelaySecondsMax,f=n*u,p=a*u,d=Math.max(0,f),m=Math.max(0,-f),S=Math.max(0,p),y=Math.max(0,-p);this.panningVolumeStartL=h,this.panningVolumeStartR=o,this.panningVolumeDeltaL=(l-h)/i,this.panningVolumeDeltaR=(c-o)/i,this.panningOffsetStartL=d,this.panningOffsetStartR=m,this.panningOffsetDeltaL=(S-d)/i,this.panningOffsetDeltaR=(y-m)/i}if(p){const t=Math.min(1,s.chorus/(e.chorusRange-1)),n=Math.min(1,s.chorus/(e.chorusRange-1));this.chorusStart=.6*t+.4*Math.pow(t,6),this.chorusEnd=.6*n+.4*Math.pow(n,6)}let O=0;if(d){const a=.9*Math.min(1,Math.pow(s.echoSustain/e.echoSustainRange,1.1)),r=.9*Math.min(1,Math.pow(s.echoSustain/e.echoSustainRange,1.1));this.echoMultStart=a,this.echoMultDelta=(r-a)/i,O=Math.max(a,r);const h=Math.round((s.echoDelay+1)*e.echoDelayStepTicks*n);this.echoDelayOffsetLastTickIsComputed?this.echoDelayOffsetStart=this.echoDelayOffsetLastTick:this.echoDelayOffsetStart=h,t.isAtEndOfTick&&(this.echoDelayOffsetLastTick=h,this.echoDelayOffsetLastTickIsComputed=!0),this.echoDelayOffsetEnd=h,this.echoDelayOffsetRatio=1-o,this.echoDelayOffsetRatioDelta=(o-l)/i;const c=2*Math.PI*e.echoShelfHz/t.samplesPerSecond;X.tempFilterStartCoefficients.highShelf1stOrder(c,e.echoShelfGain),this.echoShelfA1=X.tempFilterStartCoefficients.a[1],this.echoShelfB0=X.tempFilterStartCoefficients.b[0],this.echoShelfB1=X.tempFilterStartCoefficients.b[1]}let R=0;if(v){const n=.425*Math.min(1,Math.pow(s.reverb/e.reverbRange,.667)),a=.425*Math.min(1,Math.pow(s.reverb/e.reverbRange,.667));this.reverbMultStart=n,this.reverbMultDelta=(a-n)/i,R=Math.max(n,a);const r=2*Math.PI*e.reverbShelfHz/t.samplesPerSecond;X.tempFilterStartCoefficients.highShelf1stOrder(r,e.reverbShelfGain),this.reverbShelfA1=X.tempFilterStartCoefficients.a[1],this.reverbShelfB0=X.tempFilterStartCoefficients.b[0],this.reverbShelfB1=X.tempFilterStartCoefficients.b[1]}if(this.tonesAddedInThisTick)this.attentuationProgress=0,this.flushedSamples=0,this.flushingDelayLines=!1;else if(this.flushingDelayLines){x=0,T=0,w=0,k=0;let s=0;p&&(s+=t.chorusDelayBufferSize),d&&(s+=this.echoDelayLineL.length),v&&(s+=e.reverbDelayBufferSize),this.flushedSamples+=i,this.flushedSamples>=s&&(this.deactivateAfterThisTick=!0)}else{0==this.attentuationProgress?(x*=o,T*=l):(x=0,T=0);const s=1/256,i=-Math.log2(s);let a=0;if(p&&(a+=e.chorusMaxDelay),d){const t=.5*(this.echoDelayOffsetStart+this.echoDelayOffsetEnd)/r,e=Math.pow(O,1/t);a+=-1/Math.log2(e)*i}if(v){const t=2*R,s=e.reverbDelayBufferSize/4/r,n=Math.pow(t,1/s);a+=-1/Math.log2(n)*i}const h=n/r/a,c=this.attentuationProgress+h;c>=1&&(w*=o,k*=l),t.isAtEndOfTick&&(this.attentuationProgress=c,this.attentuationProgress>=1&&(this.flushingDelayLines=!0))}this.eqFilterVolumeStart=x,this.eqFilterVolumeDelta=(T-x)/i,this.delayInputMultStart=w,this.delayInputMultDelta=(k-w)/i}}class Q{constructor(){this.instruments=[],this.muted=!1,this.singleSeamlessInstrument=null}}class X{constructor(t=null){this.samplesPerSecond=44100,this.song=null,this.liveInputDuration=0,this.liveInputStarted=!1,this.liveInputPitches=[],this.liveInputChannel=0,this.liveInputInstruments=[],this.loopRepeatCount=-1,this.volume=1,this.playheadInternal=0,this.bar=0,this.prevBar=null,this.nextBar=null,this.beat=0,this.part=0,this.tick=0,this.isAtStartOfTick=!0,this.isAtEndOfTick=!0,this.tickSampleCountdown=0,this.isPlayingSong=!1,this.liveInputEndTime=0,this.browserAutomaticallyClearsAudioBuffer=!0,this.tempDrumSetControlPoint=new q,this.tempFrequencyResponse=new x,this.channels=[],this.tonePool=new D,this.tempMatchedPitchTones=Array(e.maxChordSize).fill(null),this.limit=0,this.tempMonoInstrumentSampleBuffer=null,this.audioCtx=null,this.scriptNode=null,this.audioProcessCallback=t=>{const e=t.outputBuffer,s=e.getChannelData(0),n=e.getChannelData(1);if(!this.browserAutomaticallyClearsAudioBuffer||0==s[0]&&0==n[0]&&0==s[e.length-1]&&0==n[e.length-1]||(this.browserAutomaticallyClearsAudioBuffer=!1),!this.browserAutomaticallyClearsAudioBuffer){const t=e.length;for(let e=0;e<t;e++)s[e]=0,n[e]=0}performance.now()<this.liveInputEndTime||this.isPlayingSong?this.synthesize(s,n,e.length,this.isPlayingSong):this.deactivateAudio()},this.computeDelayBufferSizes(),null!=t&&this.setSong(t)}syncSongState(){const t=this.song.getChannelCount();for(let e=this.channels.length;e<t;e++)this.channels[e]=new Q;this.channels.length=t;for(let e=0;e<t;e++){const t=this.song.channels[e],s=this.channels[e];for(let e=s.instruments.length;e<t.instruments.length;e++)s.instruments[e]=new $;if(s.instruments.length=t.instruments.length,s.muted!=t.muted&&(s.muted=t.muted,s.muted))for(const t of s.instruments)t.resetAllEffects()}}warmUpSynthesizer(t){if(null!=t){this.syncSongState();const e=this.getSamplesPerTick();for(let s=0;s<t.getChannelCount();s++)for(let n=0;n<t.channels[s].instruments.length;n++){const i=t.channels[s].instruments[n],a=this.channels[s].instruments[n];X.getInstrumentSynthFunction(i),i.warmUp(this.samplesPerSecond),a.allocateNecessaryBuffers(this,i,e)}}}static operatorAmplitudeCurve(t){return(Math.pow(16,t/15)-1)/15}get playing(){return this.isPlayingSong}get playhead(){return this.playheadInternal}set playhead(t){if(null!=this.song){this.playheadInternal=Math.max(0,Math.min(this.song.barCount,t));let s=this.playheadInternal;this.bar=Math.floor(s),s=this.song.beatsPerBar*(s-this.bar),this.beat=Math.floor(s),s=e.partsPerBeat*(s-this.beat),this.part=Math.floor(s),s=e.ticksPerPart*(s-this.part),this.tick=Math.floor(s);const n=this.getSamplesPerTick();s=n*(s-this.tick),this.tickSampleCountdown=n-s,this.prevBar=null}}getSamplesPerBar(){if(null==this.song)throw new Error;return this.getSamplesPerTick()*e.ticksPerPart*e.partsPerBeat*this.song.beatsPerBar}getTicksIntoBar(){return(this.beat*e.partsPerBeat+this.part)*e.ticksPerPart+this.tick}getCurrentPart(){return this.beat*e.partsPerBeat+this.part}getTotalBars(t,e){if(null==this.song)throw new Error;let s=this.song.loopLength*(this.loopRepeatCount+1);return t&&(s+=this.song.loopStart),e&&(s+=this.song.barCount-(this.song.loopStart+this.song.loopLength)),s}setSong(t){"string"==typeof t?this.song=new K(t):t instanceof K&&(this.song=t),this.prevBar=null}computeDelayBufferSizes(){this.panningDelayBufferSize=X.fittingPowerOfTwo(this.samplesPerSecond*e.panDelaySecondsMax),this.panningDelayBufferMask=this.panningDelayBufferSize-1,this.chorusDelayBufferSize=X.fittingPowerOfTwo(this.samplesPerSecond*e.chorusMaxDelay),this.chorusDelayBufferMask=this.chorusDelayBufferSize-1}activateAudio(){null!=this.audioCtx&&null!=this.scriptNode||(this.audioCtx=this.audioCtx||new(window.AudioContext||window.webkitAudioContext),this.samplesPerSecond=this.audioCtx.sampleRate,this.scriptNode=this.audioCtx.createScriptProcessor?this.audioCtx.createScriptProcessor(2048,0,2):this.audioCtx.createJavaScriptNode(2048,0,2),this.scriptNode.onaudioprocess=this.audioProcessCallback,this.scriptNode.channelCountMode="explicit",this.scriptNode.channelInterpretation="speakers",this.scriptNode.connect(this.audioCtx.destination),this.computeDelayBufferSizes()),this.audioCtx.resume()}deactivateAudio(){null!=this.audioCtx&&null!=this.scriptNode&&(this.scriptNode.disconnect(this.audioCtx.destination),this.scriptNode=null,this.audioCtx.close&&this.audioCtx.close(),this.audioCtx=null)}maintainLiveInput(){this.activateAudio(),this.liveInputEndTime=performance.now()+1e4}play(){this.isPlayingSong||(this.isPlayingSong=!0,this.activateAudio(),this.warmUpSynthesizer(this.song))}pause(){this.isPlayingSong&&(this.isPlayingSong=!1)}snapToStart(){this.bar=0,this.snapToBar()}goToBar(t){this.bar=t,this.playheadInternal=this.bar,this.prevBar=null}snapToBar(){this.playheadInternal=this.bar,this.beat=0,this.part=0,this.tick=0,this.tickSampleCountdown=0,this.isAtStartOfTick=!0,this.prevBar=null}resetEffects(){if(this.limit=0,this.freeAllTones(),null!=this.song)for(const t of this.channels)for(const e of t.instruments)e.resetAllEffects()}jumpIntoLoop(){if(this.song&&(this.bar<this.song.loopStart||this.bar>=this.song.loopStart+this.song.loopLength)){const t=this.bar;this.bar=this.song.loopStart,this.playheadInternal+=this.bar-t,this.prevBar=null}}goToNextBar(){if(!this.song)return;this.prevBar=this.bar;const t=this.bar;this.bar++,this.bar>=this.song.barCount&&(this.bar=0),this.playheadInternal+=this.bar-t}goToPrevBar(){if(!this.song)return;this.prevBar=null;const t=this.bar;this.bar--,(this.bar<0||this.bar>=this.song.barCount)&&(this.bar=this.song.barCount-1),this.playheadInternal+=this.bar-t}synthesize(t,s,n,i=!0){if(null==this.song){for(let e=0;e<n;e++)t[e]=0,s[e]=0;return void this.deactivateAudio()}const a=this.song,r=this.getSamplesPerTick();let h=!1;for(;this.tickSampleCountdown<=0;)this.tickSampleCountdown+=r;this.tickSampleCountdown>r&&(this.tickSampleCountdown=r),i&&(this.beat>=a.beatsPerBar&&(this.bar++,this.beat=0,this.part=0,this.tick=0,this.tickSampleCountdown=r,0!=this.loopRepeatCount&&this.bar==a.loopStart+a.loopLength&&(this.bar=a.loopStart,this.loopRepeatCount>0&&this.loopRepeatCount--)),this.bar>=a.barCount&&(this.bar=0,-1!=this.loopRepeatCount&&(h=!0,this.pause()))),this.syncSongState(),(null==this.tempMonoInstrumentSampleBuffer||this.tempMonoInstrumentSampleBuffer.length<n)&&(this.tempMonoInstrumentSampleBuffer=new Float32Array(n));const o=+this.volume,l=1-Math.pow(.5,4/this.samplesPerSecond),c=1-Math.pow(.5,4e3/this.samplesPerSecond);let u=+this.limit,f=0;for(;f<n&&!h;){this.nextBar=this.bar+1,0!=this.loopRepeatCount&&this.nextBar==a.loopStart+a.loopLength&&(this.nextBar=a.loopStart),this.nextBar>=a.barCount&&(this.nextBar=null);const p=n-f,d=Math.ceil(this.tickSampleCountdown),m=Math.min(d,p);this.isAtEndOfTick=m>=this.tickSampleCountdown;for(let n=0;n<a.getChannelCount();n++){const h=a.channels[n],o=this.channels[n];this.determineCurrentActiveTones(a,n,i),this.determineLiveInputTones(a,n);for(let i=0;i<h.instruments.length;i++){const l=h.instruments[i],c=o.instruments[i];let u=0;for(let t=0;t<c.activeTones.count();t++){const e=c.activeTones.get(t);this.playTone(a,n,r,f,m,e,!1,!1),u++}for(let t=0;t<c.liveInputTones.count();t++){const e=c.liveInputTones.get(t);this.playTone(a,n,r,f,m,e,!1,!1),u++}for(let t=0;t<c.releasedTones.count();t++){const s=c.releasedTones.get(t);if(s.ticksSinceReleased>=Math.abs(l.getFadeOutTicks())){this.freeReleasedTone(c,t),t--;continue}const i=u>=e.maximumTonesPerChannel;this.playTone(a,n,r,f,m,s,!0,i),u++}c.awake&&(c.computed||c.compute(this,l,r,m,null),X.effectsSynth(this,t,s,f,m,l,c),c.computed=!1)}}const S=f+m;for(let e=f;e<S;e++){const n=t[e],i=s[e],a=Math.max(Math.abs(n),Math.abs(i));u+=(a-u)*(u<a?c:l*(1+u));const r=o/(u>=1?1.05*u:.8*u+.25);t[e]=n*r,s[e]=i*r}if(f+=m,this.isAtStartOfTick=!1,this.tickSampleCountdown-=m,this.tickSampleCountdown<=0){this.isAtStartOfTick=!0;for(const t of this.channels)for(const e of t.instruments){for(let t=0;t<e.releasedTones.count();t++){const s=e.releasedTones.get(t);s.isOnLastTick?(this.freeReleasedTone(e,t),t--):s.ticksSinceReleased++}e.deactivateAfterThisTick&&e.deactivate(),e.tonesAddedInThisTick=!1}this.tick++,this.tickSampleCountdown+=r,this.tick==e.ticksPerPart&&(this.tick=0,this.part++,this.liveInputDuration--,this.part==e.partsPerBeat&&(this.part=0,i&&(this.beat++,this.beat==a.beatsPerBar&&(this.beat=0,this.prevBar=this.bar,this.bar++,0!=this.loopRepeatCount&&this.bar==a.loopStart+a.loopLength&&(this.bar=a.loopStart,this.loopRepeatCount>0&&this.loopRepeatCount--),this.bar>=a.barCount&&(this.bar=0,-1!=this.loopRepeatCount&&(h=!0,this.resetEffects(),this.pause()))))))}}(!Number.isFinite(u)||Math.abs(u)<T)&&(u=0),this.limit=u,i&&(this.playheadInternal=(((this.tick+1-this.tickSampleCountdown/r)/2+this.part)/e.partsPerBeat+this.beat)/a.beatsPerBar+this.bar)}freeTone(t){this.tonePool.pushBack(t)}newTone(){if(this.tonePool.count()>0){const t=this.tonePool.popBack();return t.freshlyAllocated=!0,t}return new _}releaseTone(t,e){t.releasedTones.pushFront(e),e.atNoteStart=!1,e.passedEndOfNote=!0}freeReleasedTone(t,e){this.freeTone(t.releasedTones.get(e)),t.releasedTones.remove(e)}freeAllTones(){for(const t of this.channels)for(const e of t.instruments){for(;e.activeTones.count()>0;)this.freeTone(e.activeTones.popBack());for(;e.releasedTones.count()>0;)this.freeTone(e.releasedTones.popBack());for(;e.liveInputTones.count()>0;)this.freeTone(e.liveInputTones.popBack())}}determineLiveInputTones(t,e){const s=t.channels[e],n=this.channels[e],i=this.liveInputPitches;for(let t=0;t<s.instruments.length;t++){const a=n.instruments[t],r=a.liveInputTones;let h=0;if(this.liveInputDuration>0&&e==this.liveInputChannel&&i.length>0&&-1!=this.liveInputInstruments.indexOf(t)){const e=s.instruments[t];if(e.getChord().singleTone){let s;r.count()<=h?(s=this.newTone(),r.pushBack(s)):!e.getTransition().isSeamless&&this.liveInputStarted?(this.releaseTone(a,r.get(h)),s=this.newTone(),r.set(h,s)):s=r.get(h),h++;for(let t=0;t<i.length;t++)s.pitches[t]=i[t];s.pitchCount=i.length,s.chordSize=1,s.instrumentIndex=t,s.note=s.prevNote=s.nextNote=null,s.atNoteStart=this.liveInputStarted,s.forceContinueAtStart=!1,s.forceContinueAtEnd=!1}else for(let s=0;s<i.length;s++){let n;r.count()<=h?(n=this.newTone(),r.pushBack(n)):!e.getTransition().isSeamless&&this.liveInputStarted?(this.releaseTone(a,r.get(h)),n=this.newTone(),r.set(h,n)):n=r.get(h),h++,n.pitches[0]=i[s],n.pitchCount=1,n.chordSize=i.length,n.instrumentIndex=t,n.note=n.prevNote=n.nextNote=null,n.atNoteStart=this.liveInputStarted,n.forceContinueAtStart=!1,n.forceContinueAtEnd=!1}}for(;r.count()>h;)this.releaseTone(a,r.popBack())}this.liveInputStarted=!1}adjacentPatternHasCompatibleInstrumentTransition(t,e,s,n,i,a,r,h,o,l){if(t.patternInstruments&&-1==n.instruments.indexOf(i)){if(s.instruments.length>1||n.instruments.length>1)return null;const t=e.instruments[n.instruments[0]];if(l)return t.getChord();const i=t.getTransition();return a.includeAdjacentPatterns&&i.includeAdjacentPatterns&&i.slides==a.slides?t.getChord():null}return l||a.includeAdjacentPatterns?r:null}static adjacentNotesHaveMatchingPitches(t,e){if(t.pitches.length!=e.pitches.length)return!1;const s=t.pins[t.pins.length-1].interval;for(const n of t.pitches)if(-1==e.pitches.indexOf(n+s))return!1;return!0}determineCurrentActiveTones(t,s,n){const i=t.channels[s],a=this.channels[s],r=t.getPattern(s,this.bar),h=this.getCurrentPart(),o=this.tick+e.ticksPerPart*h;let l=null,c=null,u=null;if(n&&null!=r&&!i.muted){for(let t=0;t<r.notes.length;t++)if(r.notes[t].end<=h)c=r.notes[t];else if(r.notes[t].start<=h&&r.notes[t].end>h)l=r.notes[t];else if(r.notes[t].start>h){u=r.notes[t];break}null!=l&&(null!=c&&c.end!=l.start&&(c=null),null!=u&&u.start!=l.end&&(u=null))}if(null!=r&&(!t.layeredInstruments||1==i.instruments.length||t.patternInstruments&&1==r.instruments.length)){const e=t.patternInstruments?r.instruments[0]:0;if(null!=a.singleSeamlessInstrument&&a.singleSeamlessInstrument!=e&&a.singleSeamlessInstrument<a.instruments.length){const t=a.instruments[a.singleSeamlessInstrument],s=a.instruments[e];for(;t.activeTones.count()>0;)s.activeTones.pushFront(t.activeTones.popBack())}a.singleSeamlessInstrument=e}else a.singleSeamlessInstrument=null;for(let n=0;n<i.instruments.length;n++){const f=a.instruments[n],p=f.activeTones;let d=0;if(null!=l&&(!t.patternInstruments||-1!=r.instruments.indexOf(n))){const a=i.instruments[n];let m=c,S=u;const y=e.partsPerBeat*t.beatsPerBar,b=a.getTransition(),M=a.getChord();let g=!1,v=!1,I=0,P=0;if(0==l.start){let e=null==this.prevBar?null:t.getPattern(s,this.prevBar);if(null!=e){const s=e.notes.length<=0?null:e.notes[e.notes.length-1];if(null!=s&&s.end==y){const a=l.continuesLastPattern&&X.adjacentNotesHaveMatchingPitches(s,l),h=this.adjacentPatternHasCompatibleInstrumentTransition(t,i,r,e,n,b,M,l,s,a);null!=h&&(m=s,I=h.singleTone?1:m.pitches.length,g=a)}}}else null!=m&&(I=M.singleTone?1:m.pitches.length);if(l.end==y){let e=null==this.nextBar?null:t.getPattern(s,this.nextBar);if(null!=e){const s=e.notes.length<=0?null:e.notes[0];if(null!=s&&0==s.start){const a=s.continuesLastPattern&&X.adjacentNotesHaveMatchingPitches(l,s),h=this.adjacentPatternHasCompatibleInstrumentTransition(t,i,r,e,n,b,M,l,s,a);null!=h&&(S=s,P=h.singleTone?1:S.pitches.length,v=a)}}}else null!=S&&(P=M.singleTone?1:S.pitches.length);if(M.singleTone){const t=e.ticksPerPart*l.start==o&&this.isAtStartOfTick;let s;if(p.count()<=d)s=this.newTone(),p.pushBack(s);else if(!t||(b.isSeamless||g)&&null!=m)s=p.get(d);else{const t=p.get(d);t.isOnLastTick?this.freeTone(t):this.releaseTone(f,t),s=this.newTone(),p.set(d,s)}d++;for(let t=0;t<l.pitches.length;t++)s.pitches[t]=l.pitches[t];s.pitchCount=l.pitches.length,s.chordSize=1,s.instrumentIndex=n,s.note=l,s.noteStartPart=l.start,s.noteEndPart=l.end,s.prevNote=m,s.nextNote=S,s.prevNotePitchIndex=0,s.nextNotePitchIndex=0,s.atNoteStart=t,s.passedEndOfNote=!1,s.forceContinueAtStart=g,s.forceContinueAtEnd=v}else{const t=a.getTransition();if((t.isSeamless&&!t.slides&&0==M.strumParts||g)&&e.ticksPerPart*l.start==o&&this.isAtStartOfTick&&null!=m){for(let t=0;t<p.count();t++){const e=p.get(t),s=e.pitches[0]+e.lastInterval;for(let n=0;n<l.pitches.length;n++)if(l.pitches[n]==s){this.tempMatchedPitchTones[n]=e,p.remove(t),t--;break}}for(;p.count()>0;){const t=p.popFront();for(let e=0;e<this.tempMatchedPitchTones.length;e++)if(null==this.tempMatchedPitchTones[e]){this.tempMatchedPitchTones[e]=t;break}}}let s=0;for(let i=0;i<l.pitches.length;i++){let a=I>i?m:null,r=l,c=P>i?S:null,u=r.start+s,y=!1;if(u>h){if(!(p.count()>i&&(t.isSeamless||g)&&null!=a))break;c=r,r=a,a=null,u=r.start+s,y=!0}let b=r.end;(t.isSeamless||g)&&null!=c&&(b=Math.min(e.partsPerBeat*this.song.beatsPerBar,b+s)),(t.continues||g)&&null!=a||(s+=M.strumParts);const D=e.ticksPerPart*u==o&&this.isAtStartOfTick;let F;if(null!=this.tempMatchedPitchTones[d])F=this.tempMatchedPitchTones[d],this.tempMatchedPitchTones[d]=null,p.pushBack(F);else if(p.count()<=d)F=this.newTone(),p.pushBack(F);else if(!D||(t.isSeamless||g)&&null!=a)F=p.get(d);else{const t=p.get(d);t.isOnLastTick?this.freeTone(t):this.releaseTone(f,t),F=this.newTone(),p.set(d,F)}d++,F.pitches[0]=r.pitches[i],F.pitchCount=1,F.chordSize=r.pitches.length,F.instrumentIndex=n,F.note=r,F.noteStartPart=u,F.noteEndPart=b,F.prevNote=a,F.nextNote=c,F.prevNotePitchIndex=i,F.nextNotePitchIndex=i,F.atNoteStart=D,F.passedEndOfNote=y,F.forceContinueAtStart=g&&null!=a,F.forceContinueAtEnd=v&&null!=c}}}for(;p.count()>d;){const e=p.popBack(),n=t.channels[s];if(e.instrumentIndex<n.instruments.length&&!e.isOnLastTick){const t=this.channels[s].instruments[e.instrumentIndex];this.releaseTone(t,e)}else this.freeTone(e)}for(let t=d;t<this.tempMatchedPitchTones.length;t++){const e=this.tempMatchedPitchTones[t];null!=e&&(e.isOnLastTick?this.freeTone(e):this.releaseTone(f,e),this.tempMatchedPitchTones[t]=null)}}}playTone(t,e,s,n,i,a,r,h){const o=t.channels[e],l=this.channels[e],c=o.instruments[a.instrumentIndex],u=l.instruments[a.instrumentIndex];u.awake=!0,u.tonesAddedInThisTick=!0,u.computed||u.compute(this,c,s,i,a),X.computeTone(this,t,e,s,i,a,r,h);X.getInstrumentSynthFunction(c)(this,n,i,a,c),a.envelopeComputer.clearEnvelopes(c)}static computeChordExpression(t){return 1/(.25*(t-1)+1)}static computeTone(t,s,n,a,r,o,l,c){const m=s.channels[n].instruments[o.instrumentIndex],S=m.getTransition(),y=m.getChord(),b=y.singleTone?1:X.computeChordExpression(o.chordSize),M=s.getChannelIsNoise(n),g=M?e.noiseInterval:1,v=e.ticksPerPart*a/t.samplesPerSecond,I=1/t.samplesPerSecond,P=1/e.partsPerBeat,D=t.tickSampleCountdown,F=1-D/a,x=1-(D-r)/a,T=t.getTicksIntoBar(),w=T/e.ticksPerPart,k=(T+1)/e.ticksPerPart,O=w+(k-w)*F,R=w+(k-w)*x,C=t.getCurrentPart();o.specialIntervalMult=1,o.specialIntervalExpressionMult=1;let E=c,B=0,A=0,N=1,z=1,W=b,V=b,G=16,U=e.keys[s.key].basePitch,j=1,K=48;if(3==m.type)j=e.spectrumBaseExpression,M&&(U=e.spectrumBasePitch,j*=2),G=e.spectrumBasePitch,K=28;else if(4==m.type)U=e.spectrumBasePitch,j=e.drumsetBaseExpression,G=U;else if(2==m.type)U=e.chipNoises[m.chipNoise].basePitch,j=e.noiseBaseExpression,G=U,K=e.chipNoises[m.chipNoise].isSoft?24:60;else if(1==m.type)j=e.fmBaseExpression;else if(0==m.type)j=e.chipBaseExpression;else if(5==m.type)j=e.harmonicsBaseExpression;else if(6==m.type)j=e.pwmBaseExpression;else{if(7!=m.type)throw new Error("Unknown instrument type in computeTone.");j=e.pickedStringBaseExpression}(o.atNoteStart&&!S.isSeamless&&!o.forceContinueAtStart||o.freshlyAllocated)&&o.reset(),o.freshlyAllocated=!1;const _=Math.max(e.maxChordSize,e.operatorCount);for(let t=0;t<_;t++)o.phaseDeltas[t]=0,o.expressionStarts[t]=0,o.expressionDeltas[t]=0,o.phaseDeltaScales[t]=0;if(l){const t=o.ticksSinceReleased+F,s=o.ticksSinceReleased+x;B=A=o.lastInterval;const n=Math.abs(m.getFadeOutTicks());N=X.noteSizeToVolumeMult((1-t/n)*e.noteSizeMax),z=X.noteSizeToVolumeMult((1-s/n)*e.noteSizeMax),c&&(N*=1-F,z*=1-x),o.ticksSinceReleased+1>=n&&(E=!0)}else if(null==o.note)N=z=1,o.lastInterval=0,o.ticksSinceReleased=0,o.liveInputSamplesHeld+=r;else{const s=o.note,n=o.nextNote,i=o.noteStartPart,a=o.noteEndPart,r=s.getEndPinIndex(C),h=s.pins[r-1],l=s.pins[r],c=i*e.ticksPerPart,u=a*e.ticksPerPart,f=(s.start+h.time)*e.ticksPerPart,p=(s.start+l.time)*e.ticksPerPart;o.ticksSinceReleased=0;const d=C*e.ticksPerPart+t.tick,y=C*e.ticksPerPart+t.tick+1,b=d-c,M=y-c,g=Math.min(1,(d-f)/(p-f)),v=Math.min(1,(y-f)/(p-f));let I=1,P=1,D=h.interval+(l.interval-h.interval)*g,L=h.interval+(l.interval-h.interval)*v;if(o.lastInterval=L,!S.isSeamless&&!o.forceContinueAtEnd||null==n){const t=-m.getFadeOutTicks();if(t>0){const e=u-c;I*=Math.min(1,(e-b)/t),P*=Math.min(1,(e-M)/t),y>=c+e&&(E=!0)}}B=D+(L-D)*F,A=D+(L-D)*x,N=I+(P-I)*F,z=I+(P-I)*x}o.isOnLastTick=E;const $=o.envelopeComputer;$.computeEnvelopes(m,C,e.ticksPerPart*O,e.ticksPerPart*R,v*(R-O),o);const Q=o.envelopeComputer.envelopeStarts,Y=o.envelopeComputer.envelopeEnds;if(null!=o.note&&S.slides){const t=o.prevNote,e=o.nextNote;if(null!=t){const e=t.pitches[o.prevNotePitchIndex]+t.pins[t.pins.length-1].interval-o.pitches[0];if($.prevSlideStart&&(B+=e*$.prevSlideRatioStart),$.prevSlideEnd&&(A+=e*$.prevSlideRatioEnd),!y.singleTone){const e=t.pitches.length-o.chordSize;$.prevSlideStart&&(W=X.computeChordExpression(o.chordSize+e*$.prevSlideRatioStart)),$.prevSlideEnd&&(V=X.computeChordExpression(o.chordSize+e*$.prevSlideRatioEnd))}}if(null!=e){const t=e.pitches[o.nextNotePitchIndex]-(o.pitches[0]+o.note.pins[o.note.pins.length-1].interval);if($.nextSlideStart&&(B+=t*$.nextSlideRatioStart),$.nextSlideEnd&&(A+=t*$.nextSlideRatioEnd),!y.singleTone){const t=e.pitches.length-o.chordSize;$.nextSlideStart&&(W=X.computeChordExpression(o.chordSize+t*$.nextSlideRatioStart)),$.nextSlideEnd&&(V=X.computeChordExpression(o.chordSize+t*$.nextSlideRatioEnd))}}}if(u(m.effects)){const t=e.justIntonationSemitones[m.pitchShift]/g;B+=t*Q[14],A+=t*Y[14]}if(f(m.effects)){const t=Q[15],s=Y[15];B+=X.detuneToCents((m.detune-e.detuneCenter)*t)*e.pitchesPerOctave/1200,A+=X.detuneToCents((m.detune-e.detuneCenter)*s)*e.pitchesPerOctave/1200}if(p(m.effects)){const t=e.vibratos[m.vibrato].delayTicks,s=e.vibratos[m.vibrato].amplitude;let n;if(null!=o.prevVibrato)n=o.prevVibrato;else{if(n=s*X.getLFOAmplitude(m,v*O)*Q[16],t>0){const e=t-$.noteTicksStart;n*=Math.max(0,Math.min(1,1-e/2))}}let i=s*X.getLFOAmplitude(m,v*R)*Y[16];if(t>0){const e=t-$.noteTicksEnd;i*=Math.max(0,Math.min(1,1-e/2))}o.prevVibrato=i,B+=n,A+=i}if(!S.isSeamless&&!o.forceContinueAtStart||null==o.prevNote){const t=m.getFadeInSeconds();t>0&&(N*=Math.min(1,$.noteSecondsStart/t),z*=Math.min(1,$.noteSecondsEnd/t))}4==m.type&&null==o.drumsetPitch&&(o.drumsetPitch=o.pitches[0],null!=o.note&&(o.drumsetPitch+=o.note.pickMainInterval()),o.drumsetPitch=Math.max(0,Math.min(e.drumCount-1,o.drumsetPitch)));let tt=$.lowpassCutoffDecayVolumeCompensation;if(d(m.effects)){const e=m.noteFilter,s=Q[1],n=Y[1];for(let i=0;i<e.controlPointCount;i++){const a=Q[17+i],h=Y[17+i],l=Q[25+i],c=Y[25+i],u=e.controlPoints[i];u.toCoefficients(X.tempFilterStartCoefficients,t.samplesPerSecond,s*a,l),u.toCoefficients(X.tempFilterEndCoefficients,t.samplesPerSecond,n*h,c),o.noteFilters.length<=i&&(o.noteFilters[i]=new L),o.noteFilters[i].loadCoefficientsWithGradient(X.tempFilterStartCoefficients,X.tempFilterEndCoefficients,1/r,0==u.type),tt*=u.getVolumeCompensationMult()}o.noteFilterCount=e.controlPointCount}else o.noteFilterCount=0;if(4==m.type){const e=m.getDrumsetEnvelope(o.drumsetPitch);tt*=Z.getLowpassCutoffDecayVolumeCompensation(e);let s=Z.computeEnvelope(e,$.noteSecondsStart,P*O,$.noteSizeStart),n=Z.computeEnvelope(e,$.noteSecondsEnd,P*R,$.noteSizeEnd);if($.prevSlideStart){s+=(Z.computeEnvelope(e,$.prevNoteSecondsStart,P*O,$.prevNoteSize)-s)*$.prevSlideRatioStart}if($.prevSlideEnd){n+=(Z.computeEnvelope(e,$.prevNoteSecondsEnd,P*R,$.prevNoteSize)-n)*$.prevSlideRatioEnd}if($.nextSlideStart){s+=(Z.computeEnvelope(e,0,P*O,$.nextNoteSize)-s)*$.nextSlideRatioStart}if($.nextSlideEnd){n+=(Z.computeEnvelope(e,0,P*R,$.nextNoteSize)-n)*$.nextSlideRatioEnd}const i=t.tempDrumSetControlPoint;i.type=0,i.gain=q.getRoundedSettingValueFromLinearGain(.5),i.freq=q.getRoundedSettingValueFromHz(8e3),i.toCoefficients(X.tempFilterStartCoefficients,t.samplesPerSecond,s*(1+s),1),i.toCoefficients(X.tempFilterEndCoefficients,t.samplesPerSecond,n*(1+n),1),o.noteFilters.length==o.noteFilterCount&&(o.noteFilters[o.noteFilterCount]=new L),o.noteFilters[o.noteFilterCount].loadCoefficientsWithGradient(X.tempFilterStartCoefficients,X.tempFilterEndCoefficients,1/r,!0),o.noteFilterCount++}if(tt=Math.min(3,tt),1==m.type){let n=1,i=0,a=0;const l=y.arpeggiates;if(o.pitchCount>1&&l){const n=Math.floor((t.tick+t.part*e.ticksPerPart)/e.rhythms[s.rhythm].ticksPerArpeggio);a=o.pitches[h(o.pitchCount,s.rhythm,n)]-o.pitches[0]}const c=e.algorithms[m.algorithm].carrierCount;for(let t=0;t<e.operatorCount;t++){const s=e.algorithms[m.algorithm].associatedCarrier[t]-1,h=o.pitches[l?0:t<o.pitchCount?t:s<o.pitchCount?s:0],u=e.operatorFrequencies[m.operators[t].frequency].mult,f=e.operatorCarrierInterval[s]+a,p=U+(h+B)*g+f,d=U+(h+A)*g+f,S=H.frequencyFromPitch(p),y=H.frequencyFromPitch(d),b=e.operatorFrequencies[m.operators[t].frequency].hzOffset,M=u*S+b,v=u*y+b,P=Q[5+t],D=Y[5+t];let F,x;1!=P||1!=D?(F=Math.pow(2,Math.log2(M/S)*P)*S,x=Math.pow(2,Math.log2(v/y)*D)*y):(F=M,x=v),o.phaseDeltas[t]=F*I*e.sineWaveLength,o.phaseDeltaScales[t]=Math.pow(x/F,1/r);const L=X.operatorAmplitudeCurve(m.operators[t].amplitude),T=L*e.operatorFrequencies[m.operators[t].frequency].amplitudeSign;let w=T,k=T;if(t<c){const t=Math.pow(2,-(p-G)/K),e=Math.pow(2,-(d-G)/K);w*=j*t*N*tt*W,k*=j*e*z*tt*V,w*=Q[0],k*=Y[0],i+=L}else w*=1.5*e.sineWaveLength,k*=1.5*e.sineWaveLength,n*=1-Math.min(1,m.operators[t].amplitude/15);w*=Q[9+t],k*=Y[9+t],o.expressionStarts[t]=w,o.expressionDeltas[t]=(k-w)/r}n*=(Math.pow(2,2-1.4*m.feedbackAmplitude/15)-1)/3,n*=1-Math.min(1,Math.max(0,i-1)/2),n=1+3*n;for(let t=0;t<c;t++)o.expressionStarts[t]*=n,o.expressionDeltas[t]*=n;const u=.3*e.sineWaveLength*m.feedbackAmplitude/15;let f=u*Q[13],p=u*Y[13];o.feedbackMult=f,o.feedbackDelta=(p-o.feedbackMult)/r}else{const n=Math.pow(2,(A-B)*g/12/r);let a=o.pitches[0];if(o.pitchCount>1&&(y.arpeggiates||y.customInterval)){const n=Math.floor((t.tick+t.part*e.ticksPerPart)/e.rhythms[s.rhythm].ticksPerArpeggio);if(y.customInterval){const t=o.pitches[1+h(o.pitchCount-1,s.rhythm,n)]-o.pitches[0];o.specialIntervalMult=Math.pow(2,t/12),o.specialIntervalExpressionMult=Math.pow(2,-t/K)}else a=o.pitches[h(o.pitchCount,s.rhythm,n)]}const l=U+(a+B)*g,c=U+(a+A)*g,u=Math.pow(2,-(l-G)/K),f=Math.pow(2,-(c-G)/K);let p=j*tt;if(2==m.type&&(p*=e.chipNoises[m.chipNoise].expression),0==m.type&&(p*=e.chipWaves[m.chipWave].expression),6==m.type){const t=i(m.pulseWidth),e=t*Q[2],s=t*Y[2];o.pulseWidth=e,o.pulseWidthDelta=(s-e)/r}if(7==m.type){p*=Math.pow(2,.7*(1-m.stringSustain/(e.stringSustainRange-1)));const t=e.unisons[m.unison];for(let e=o.pickedStrings.length;e<t.voices;e++)o.pickedStrings[e]=new J;if(o.atNoteStart&&!S.continues&&!o.forceContinueAtStart)for(const t of o.pickedStrings)t.delayIndex=-1}const d=H.frequencyFromPitch(l);if(0==m.type||5==m.type||7==m.type){const t=e.unisons[m.unison],s=7==m.type?1:t.voices/2;p*=t.expression*s;const i=Q[4],a=Y[4],h=Math.pow(2,(t.offset+t.spread)*i/12),l=Math.pow(2,(t.offset+t.spread)*a/12),c=Math.pow(2,(t.offset-t.spread)*i/12)*o.specialIntervalMult,u=Math.pow(2,(t.offset-t.spread)*a/12)*o.specialIntervalMult;o.phaseDeltas[0]=d*I*h,o.phaseDeltas[1]=d*I*c,o.phaseDeltaScales[0]=n*Math.pow(l/h,1/r),o.phaseDeltaScales[1]=n*Math.pow(u/c,1/r)}else o.phaseDeltas[0]=d*I,o.phaseDeltaScales[0]=n;let b=p*N*W*u*Q[0],M=p*z*V*f*Y[0];o.expressionStarts[0]=b,o.expressionDeltas[0]=(M-b)/r}}static getLFOAmplitude(t,s){let n=0;for(const i of e.vibratos[t.vibrato].periodsSeconds)n+=Math.sin(2*Math.PI*s/i);return n}static getInstrumentSynthFunction(t){if(1==t.type){const s=t.algorithm+"_"+t.feedbackType;if(null==X.fmSynthFunctionCache[s]){const n=[];for(const s of X.fmSourceTemplate)if(-1!=s.indexOf("// CARRIER OUTPUTS")){const i=[];for(let s=0;s<e.algorithms[t.algorithm].carrierCount;s++)i.push("operator"+s+"Scaled");n.push(s.replace("/*operator#Scaled*/",i.join(" + ")))}else if(-1!=s.indexOf("// INSERT OPERATOR COMPUTATION HERE"))for(let s=e.operatorCount-1;s>=0;s--)for(const i of X.operatorSourceTemplate)if(-1!=i.indexOf("/* + operator@Scaled*/")){let a="";for(const n of e.algorithms[t.algorithm].modulatedBy[s])a+=" + operator"+(n-1)+"Scaled";const r=e.feedbacks[t.feedbackType].indices[s];if(r.length>0){a+=" + feedbackMult * (";const t=[];for(const e of r)t.push("operator"+(e-1)+"Output");a+=t.join(" + ")+")"}n.push(i.replace(/\#/g,s+"").replace("/* + operator@Scaled*/",a))}else n.push(i.replace(/\#/g,s+""));else if(-1!=s.indexOf("#"))for(let t=0;t<e.operatorCount;t++)n.push(s.replace(/\#/g,t+""));else n.push(s);X.fmSynthFunctionCache[s]=new Function("synth","bufferIndex","runLength","tone","instrument",n.join("\n"))}return X.fmSynthFunctionCache[s]}if(0==t.type)return X.chipSynth;if(5==t.type)return X.harmonicsSynth;if(6==t.type)return X.pulseWidthSynth;if(7==t.type)return X.pickedStringSynth;if(2==t.type)return X.noiseSynth;if(3==t.type)return X.spectrumSynth;if(4==t.type)return X.drumsetSynth;throw new Error("Unrecognized instrument type: "+t.type)}static chipSynth(t,s,n,i,a){const r=t.tempMonoInstrumentSampleBuffer,h=e.chipWaves[a.chipWave].samples,o=h.length-1,l=i.specialIntervalExpressionMult*e.unisons[a.unison].sign;0!=a.unison||a.getChord().customInterval||(i.phases[1]=i.phases[0]);let c=i.phaseDeltas[0]*o,u=i.phaseDeltas[1]*o;const f=+i.phaseDeltaScales[0],p=+i.phaseDeltaScales[1];let d=+i.expressionStarts[0];const m=+i.expressionDeltas[0];let S=i.phases[0]%1*o,y=i.phases[1]%1*o;const b=i.noteFilters,M=0|i.noteFilterCount;let g=+i.initialNoteFilterInput1,v=+i.initialNoteFilterInput2;const I=X.applyFilters,P=0|S,D=0|y,F=P%o,x=D%o,L=S-P,T=y-D;let w=+h[F],k=+h[x];w+=(h[F+1]-w)*L,k+=(h[x+1]-k)*T;const O=s+n;for(let t=s;t<O;t++){S+=c,y+=u;const e=0|S,s=0|y,n=e%o,i=s%o;let a=h[n],P=h[i];const D=S-e,F=y-s;a+=(h[n+1]-a)*D,P+=(h[i+1]-P)*F;const x=(a-w)/c,L=(P-k)/u;w=a,k=P;const T=x+L*l,O=I(T,g,v,M,b);v=g,g=T,c*=f,u*=p;const R=O*d;d+=m,r[t]+=R}i.phases[0]=S/o,i.phases[1]=y/o,t.sanitizeFilters(b),i.initialNoteFilterInput1=g,i.initialNoteFilterInput2=v}static harmonicsSynth(t,s,n,i,a){const r=t.tempMonoInstrumentSampleBuffer,h=a.harmonicsWave.getCustomWave(a.type),o=h.length-1,l=i.specialIntervalExpressionMult*e.unisons[a.unison].sign;0!=a.unison||a.getChord().customInterval||(i.phases[1]=i.phases[0]);let c=i.phaseDeltas[0]*o,u=i.phaseDeltas[1]*o;const f=+i.phaseDeltaScales[0],p=+i.phaseDeltaScales[1];let d=+i.expressionStarts[0];const m=+i.expressionDeltas[0];let S=i.phases[0]%1*o,y=i.phases[1]%1*o;const b=i.noteFilters,M=0|i.noteFilterCount;let g=+i.initialNoteFilterInput1,v=+i.initialNoteFilterInput2;const I=X.applyFilters,P=0|S,D=0|y,F=P%o,x=D%o,L=S-P,T=y-D;let w=+h[F],k=+h[x];w+=(h[F+1]-w)*L,k+=(h[x+1]-k)*T;const O=s+n;for(let t=s;t<O;t++){S+=c,y+=u;const e=0|S,s=0|y,n=e%o,i=s%o;let a=h[n],P=h[i];const D=S-e,F=y-s;a+=(h[n+1]-a)*D,P+=(h[i+1]-P)*F;const x=(a-w)/c,L=(P-k)/u;w=a,k=P;const T=x+L*l,O=I(T,g,v,M,b);v=g,g=T,c*=f,u*=p;const R=O*d;d+=m,r[t]+=R}i.phases[0]=S/o,i.phases[1]=y/o,t.sanitizeFilters(b),i.initialNoteFilterInput1=g,i.initialNoteFilterInput2=v}static pickedStringSynth(t,s,n,i,a){const r=e.unisons[a.unison].voices;let h=X.pickedStringFunctionCache[r];if(null==h){let t="";t+=`\n\t\t\t\t\n\t\t\t\tconst Config = beepbox.Config;\n\t\t\t\tconst Synth = beepbox.Synth;\n\t\t\t\tconst NoteAutomationStringSustainIndex = 3;\n\t\t\t\tconst voiceCount = ${r};\n\t\t\t\tconst data = synth.tempMonoInstrumentSampleBuffer;\n\t\t\t\t\n\t\t\t\tconst sustainEnvelopeStart = tone.envelopeComputer.envelopeStarts[NoteAutomationStringSustainIndex];\n\t\t\t\tconst sustainEnvelopeEnd   = tone.envelopeComputer.envelopeEnds[  NoteAutomationStringSustainIndex];\n\t\t\t\tconst stringDecayStart = 1.0 - Math.min(1.0, sustainEnvelopeStart * instrument.stringSustain / (Config.stringSustainRange - 1));\n\t\t\t\tconst stringDecayEnd   = 1.0 - Math.min(1.0, sustainEnvelopeEnd   * instrument.stringSustain / (Config.stringSustainRange - 1));\n\t\t\t\t\n\t\t\t\tlet pickedString# = tone.pickedStrings[#];\n\t\t\t\t\n\t\t\t\tconst prevDelayLength# = +pickedString#.prevDelayLength;\n\t\t\t\tlet allPassSample# = +pickedString#.allPassSample;\n\t\t\t\tlet allPassPrevInput# = +pickedString#.allPassPrevInput;\n\t\t\t\tlet shelfSample# = +pickedString#.shelfSample;\n\t\t\t\tlet shelfPrevInput# = +pickedString#.shelfPrevInput;\n\t\t\t\tlet fractionalDelaySample# = +pickedString#.fractionalDelaySample;\n\t\t\t\t\n\t\t\t\tlet expression = +tone.expressionStarts[0];\n\t\t\t\tconst expressionDelta = +tone.expressionDeltas[0];\n\t\t\t\t\n\t\t\t\tconst phaseDeltaStart# = +tone.phaseDeltas[#];\n\t\t\t\tconst phaseDeltaScale# = +tone.phaseDeltaScales[#];\n\t\t\t\tconst phaseDeltaEnd# = phaseDeltaStart# * Math.pow(phaseDeltaScale#, runLength);\n\t\t\t\t\n\t\t\t\tconst radiansPerSampleStart# = Math.PI * 2.0 * phaseDeltaStart#;\n\t\t\t\tconst radiansPerSampleEnd#   = Math.PI * 2.0 * phaseDeltaEnd#;\n\t\t\t\t\n\t\t\t\tconst centerHarmonicStart# = radiansPerSampleStart# * 2.0;\n\t\t\t\tconst centerHarmonicEnd#   = radiansPerSampleEnd# * 2.0;\n\t\t\t\t\n\t\t\t\tconst allPassCenter = 2.0 * Math.PI * Config.pickedStringDispersionCenterFreq / synth.samplesPerSecond;\n\t\t\t\tconst allPassRadiansStart# = Math.min(Math.PI, radiansPerSampleStart# * Config.pickedStringDispersionFreqMult * Math.pow(allPassCenter / radiansPerSampleStart#, Config.pickedStringDispersionFreqScale));\n\t\t\t\tconst allPassRadiansEnd# = Math.min(Math.PI, radiansPerSampleEnd# * Config.pickedStringDispersionFreqMult * Math.pow(allPassCenter / radiansPerSampleEnd#, Config.pickedStringDispersionFreqScale));\n\t\t\t\t\n\t\t\t\tconst shelfRadians = 2.0 * Math.PI * Config.pickedStringShelfHz / synth.samplesPerSecond;\n\t\t\t\tconst decayCurveStart = (Math.pow(100.0, stringDecayStart) - 1.0) / 99.0;\n\t\t\t\tconst decayCurveEnd   = (Math.pow(100.0, stringDecayEnd  ) - 1.0) / 99.0;\n\t\t\t\tconst decayRateStart# = Math.pow(0.5, decayCurveStart * shelfRadians / radiansPerSampleStart#);\n\t\t\t\tconst decayRateEnd#   = Math.pow(0.5, decayCurveEnd   * shelfRadians / radiansPerSampleEnd#);\n\t\t\t\tconst shelfGainStart# = Math.pow(decayRateStart#, Config.stringDecayRate);\n\t\t\t\tconst shelfGainEnd#   = Math.pow(decayRateEnd#,   Config.stringDecayRate);\n\t\t\t\tconst expressionDecayStart# = Math.pow(decayRateStart#, 0.002);\n\t\t\t\tconst expressionDecayEnd#   = Math.pow(decayRateEnd#,   0.002);`;for(let e=0;e<r;e++)t+="\n\t\t\t\t\n\t\t\t\tSynth.tempFilterStartCoefficients.allPass1stOrderInvertPhaseAbove(allPassRadiansStart#);\n\t\t\t\tsynth.tempFrequencyResponse.analyze(Synth.tempFilterStartCoefficients, centerHarmonicStart#);\n\t\t\t\tlet allPassG# = +Synth.tempFilterStartCoefficients.b[0]; /* same as a[1] */\n\t\t\t\tconst allPassPhaseDelayStart# = -synth.tempFrequencyResponse.angle() / centerHarmonicStart#;\n\t\t\t\t\n\t\t\t\tSynth.tempFilterEndCoefficients.allPass1stOrderInvertPhaseAbove(allPassRadiansEnd#);\n\t\t\t\tsynth.tempFrequencyResponse.analyze(Synth.tempFilterEndCoefficients, centerHarmonicEnd#);\n\t\t\t\tconst allPassGEnd# = +Synth.tempFilterEndCoefficients.b[0]; /* same as a[1] */\n\t\t\t\tconst allPassPhaseDelayEnd# = -synth.tempFrequencyResponse.angle() / centerHarmonicEnd#;\n\t\t\t\t\n\t\t\t\tSynth.tempFilterStartCoefficients.highShelf1stOrder(shelfRadians, shelfGainStart#);\n\t\t\t\tsynth.tempFrequencyResponse.analyze(Synth.tempFilterStartCoefficients, centerHarmonicStart#)\n\t\t\t\tlet shelfA1# = +Synth.tempFilterStartCoefficients.a[1]\n\t\t\t\tlet shelfB0# = Synth.tempFilterStartCoefficients.b[0] * expressionDecayStart#\n\t\t\t\tlet shelfB1# = Synth.tempFilterStartCoefficients.b[1] * expressionDecayStart#\n\t\t\t\tconst shelfPhaseDelayStart# = -synth.tempFrequencyResponse.angle() / centerHarmonicStart#;\n\t\t\t\t\n\t\t\t\tSynth.tempFilterEndCoefficients.highShelf1stOrder(shelfRadians, shelfGainEnd#)\n\t\t\t\tsynth.tempFrequencyResponse.analyze(Synth.tempFilterEndCoefficients, centerHarmonicEnd#)\n\t\t\t\tconst shelfA1End# = +Synth.tempFilterEndCoefficients.a[1]\n\t\t\t\tconst shelfB0End# = Synth.tempFilterEndCoefficients.b[0] * expressionDecayEnd#\n\t\t\t\tconst shelfB1End# = Synth.tempFilterEndCoefficients.b[1] * expressionDecayEnd#\n\t\t\t\tconst shelfPhaseDelayEnd# = -synth.tempFrequencyResponse.angle() / centerHarmonicEnd#;".replace(/\#/g,String(e));t+="\n\t\t\t\t\n\t\t\t\tconst periodLengthStart# = 1.0 / phaseDeltaStart#;\n\t\t\t\tconst periodLengthEnd# = 1.0 / phaseDeltaEnd#;\n\t\t\t\tconst minBufferLength# = Math.ceil(Math.max(periodLengthStart#, periodLengthEnd#) * 2);\n\t\t\t\tlet delayLength# = periodLengthStart# - allPassPhaseDelayStart# - shelfPhaseDelayStart#;\n\t\t\t\tconst delayLengthEnd# = periodLengthEnd# - allPassPhaseDelayEnd# - shelfPhaseDelayEnd#;\n\t\t\t\t\n\t\t\t\tconst delayLengthDelta# = (delayLengthEnd# - delayLength#) / runLength;\n\t\t\t\tconst allPassGDelta# = (allPassGEnd# - allPassG#) / runLength;\n\t\t\t\tconst shelfA1Delta# = (shelfA1End# - shelfA1#) / runLength;\n\t\t\t\tconst shelfB0Delta# = (shelfB0End# - shelfB0#) / runLength;\n\t\t\t\tconst shelfB1Delta# = (shelfB1End# - shelfB1#) / runLength;\n\t\t\t\t\n\t\t\t\tconst filters = tone.noteFilters;\n\t\t\t\tconst filterCount = tone.noteFilterCount|0;\n\t\t\t\tlet initialFilterInput1 = +tone.initialNoteFilterInput1;\n\t\t\t\tlet initialFilterInput2 = +tone.initialNoteFilterInput2;\n\t\t\t\tconst applyFilters = Synth.applyFilters;\n\t\t\t\t\n\t\t\t\tconst pitchChanged# = Math.abs(Math.log2(delayLength# / prevDelayLength#)) > 0.01;\n\t\t\t\tlet delayIndex# = pickedString#.delayIndex|0;";for(let e=0;e<r;e++)t+="\n\t\t\t\t\n\t\t\t\tconst reinitializeImpulse# = (delayIndex# == -1 || pitchChanged#);\n\t\t\t\tif (pickedString#.delayLine == null || pickedString#.delayLine.length <= minBufferLength#) {\n\t\t\t\t\t// The delay line buffer will get reused for other tones so might as well\n\t\t\t\t\t// start off with a buffer size that is big enough for most notes.\n\t\t\t\t\tconst likelyMaximumLength = Math.ceil(2 * synth.samplesPerSecond / beepbox.Instrument.frequencyFromPitch(12));\n\t\t\t\t\tconst newDelayLine = new Float32Array(Synth.fittingPowerOfTwo(Math.max(likelyMaximumLength, minBufferLength#)));\n\t\t\t\t\tif (!reinitializeImpulse# && pickedString#.delayLine != null) {\n\t\t\t\t\t\t// If the tone has already started but the buffer needs to be reallocated,\n\t\t\t\t\t\t// transfer the old data to the new buffer.\n\t\t\t\t\t\tconst oldDelayBufferMask = (pickedString#.delayLine.length - 1) >> 0;\n\t\t\t\t\t\tconst startCopyingFromIndex = delayIndex# + pickedString#.delayResetOffset;\n\t\t\t\t\t\tdelayIndex# = pickedString#.delayLine.length - pickedString#.delayResetOffset;\n\t\t\t\t\t\tfor (let i = 0; i < pickedString#.delayLine.length; i++) {\n\t\t\t\t\t\t\tnewDelayLine[i] = pickedString#.delayLine[(startCopyingFromIndex + i) & oldDelayBufferMask];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpickedString#.delayLine = newDelayLine;\n\t\t\t\t}\n\t\t\t\tconst delayLine# = pickedString#.delayLine;\n\t\t\t\tconst delayBufferMask# = (delayLine#.length - 1) >> 0;\n\t\t\t\t\n\t\t\t\tif (reinitializeImpulse#) {\n\t\t\t\t\t// -1 delay index means the tone was reset.\n\t\t\t\t\t// Also, if the pitch changed suddenly (e.g. from seamless or arpeggio) then reset the wave.\n\t\t\t\t\t\n\t\t\t\t\tdelayIndex# = 0;\n\t\t\t\t\tallPassSample# = 0.0;\n\t\t\t\t\tallPassPrevInput# = 0.0;\n\t\t\t\t\tshelfSample# = 0.0;\n\t\t\t\t\tshelfPrevInput# = 0.0;\n\t\t\t\t\tfractionalDelaySample# = 0.0;\n\t\t\t\t\t\n\t\t\t\t\t// Clear away a region of the delay buffer for the new impulse.\n\t\t\t\t\tconst startImpulseFrom = -delayLength#;\n\t\t\t\t\tconst startZerosFrom = Math.floor(startImpulseFrom - periodLengthStart# / 2);\n\t\t\t\t\tconst stopZerosAt = Math.ceil(startZerosFrom + periodLengthStart# * 2);\n\t\t\t\t\tpickedString#.delayResetOffset = stopZerosAt; // And continue clearing the area in front of the delay line.\n\t\t\t\t\tfor (let i = startZerosFrom; i <= stopZerosAt; i++) {\n\t\t\t\t\t\tdelayLine#[i & delayBufferMask#] = 0.0;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconst impulseWave = instrument.harmonicsWave.getCustomWave(instrument.type);\n\t\t\t\t\tconst impulseWaveLength = impulseWave.length - 1; // The first sample is duplicated at the end, don't double-count it.\n\t\t\t\t\tconst impulsePhaseDelta = impulseWaveLength / periodLengthStart#;\n\t\t\t\t\t\n\t\t\t\t\tconst fadeDuration = Math.min(periodLengthStart# * 0.2, synth.samplesPerSecond * 0.003);\n\t\t\t\t\tconst startImpulseFromSample = Math.ceil(startImpulseFrom);\n\t\t\t\t\tconst stopImpulseAt = startImpulseFrom + periodLengthStart# + fadeDuration;\n\t\t\t\t\tconst stopImpulseAtSample = stopImpulseAt;\n\t\t\t\t\tlet impulsePhase = (startImpulseFromSample - startImpulseFrom) * impulsePhaseDelta;\n\t\t\t\t\tlet prevWaveIntegral = 0.0;\n\t\t\t\t\tfor (let i = startImpulseFromSample; i <= stopImpulseAtSample; i++) {\n\t\t\t\t\t\tconst impulsePhaseInt = impulsePhase|0;\n\t\t\t\t\t\tconst index = impulsePhaseInt % impulseWaveLength;\n\t\t\t\t\t\tlet nextWaveIntegral = impulseWave[index];\n\t\t\t\t\t\tconst phaseRatio = impulsePhase - impulsePhaseInt;\n\t\t\t\t\t\tnextWaveIntegral += (impulseWave[index+1] - nextWaveIntegral) * phaseRatio;\n\t\t\t\t\t\tconst sample = (nextWaveIntegral - prevWaveIntegral) / impulsePhaseDelta;\n\t\t\t\t\t\tconst fadeIn = Math.min(1.0, (i - startImpulseFrom) / fadeDuration);\n\t\t\t\t\t\tconst fadeOut = Math.min(1.0, (stopImpulseAt - i) / fadeDuration);\n\t\t\t\t\t\tconst combinedFade = fadeIn * fadeOut;\n\t\t\t\t\t\tconst curvedFade = combinedFade * combinedFade * (3.0 - 2.0 * combinedFade); // A cubic sigmoid from 0 to 1.\n\t\t\t\t\t\tdelayLine#[i & delayBufferMask#] += sample * curvedFade;\n\t\t\t\t\t\tprevWaveIntegral = nextWaveIntegral;\n\t\t\t\t\t\timpulsePhase += impulsePhaseDelta;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdelayIndex# = (delayIndex# & delayBufferMask#) + delayLine#.length;".replace(/\#/g,String(e));t+="\n\t\t\t\t\n\t\t\t\tconst unisonSign = tone.specialIntervalExpressionMult * Config.unisons[instrument.unison].sign;\n\t\t\t\tconst delayResetOffset# = pickedString#.delayResetOffset|0;\n\t\t\t\t\n\t\t\t\tconst stopIndex = bufferIndex + runLength;\n\t\t\t\tfor (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\n\t\t\t\t\tconst targetSampleTime# = delayIndex# - delayLength#;\n\t\t\t\t\tconst lowerIndex# = (targetSampleTime# + 0.125) | 0; // Offset to improve stability of all-pass filter.\n\t\t\t\t\tconst upperIndex# = lowerIndex# + 1;\n\t\t\t\t\tconst fractionalDelay# = upperIndex# - targetSampleTime#;\n\t\t\t\t\tconst fractionalDelayG# = (1.0 - fractionalDelay#) / (1.0 + fractionalDelay#); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\n\t\t\t\t\tconst prevInput# = delayLine#[lowerIndex# & delayBufferMask#];\n\t\t\t\t\tconst input# = delayLine#[upperIndex# & delayBufferMask#];\n\t\t\t\t\tfractionalDelaySample# = fractionalDelayG# * input# + prevInput# - fractionalDelayG# * fractionalDelaySample#;\n\t\t\t\t\t\n\t\t\t\t\tallPassSample# = fractionalDelaySample# * allPassG# + allPassPrevInput# - allPassG# * allPassSample#;\n\t\t\t\t\tallPassPrevInput# = fractionalDelaySample#;\n\t\t\t\t\t\n\t\t\t\t\tshelfSample# = shelfB0# * allPassSample# + shelfB1# * shelfPrevInput# - shelfA1# * shelfSample#;\n\t\t\t\t\tshelfPrevInput# = allPassSample#;\n\t\t\t\t\t\n\t\t\t\t\tdelayLine#[delayIndex# & delayBufferMask#] += shelfSample#;\n\t\t\t\t\tdelayLine#[(delayIndex# + delayResetOffset#) & delayBufferMask#] = 0.0;\n\t\t\t\t\tdelayIndex#++;\n\t\t\t\t\t\n\t\t\t\t\tconst inputSample = (";const e=[];for(let t=0;t<r;t++)e.push("fractionalDelaySample"+t+(1==t?" * unisonSign":""));t+=e.join(" + "),t+=") * expression;\n\t\t\t\t\tconst sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\n\t\t\t\t\tinitialFilterInput2 = initialFilterInput1;\n\t\t\t\t\tinitialFilterInput1 = inputSample;\n\t\t\t\t\tdata[sampleIndex] += sample;\n\t\t\t\t\t\n\t\t\t\t\texpression += expressionDelta;\n\t\t\t\t\tdelayLength# += delayLengthDelta#;\n\t\t\t\t\tallPassG# += allPassGDelta#;\n\t\t\t\t\tshelfA1# += shelfA1Delta#;\n\t\t\t\t\tshelfB0# += shelfB0Delta#;\n\t\t\t\t\tshelfB1# += shelfB1Delta#;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Avoid persistent denormal or NaN values in the delay buffers and filter history.\n\t\t\t\tconst epsilon = (1.0e-24);\n\t\t\t\tif (!Number.isFinite(allPassSample#) || Math.abs(allPassSample#) < epsilon) allPassSample# = 0.0;\n\t\t\t\tif (!Number.isFinite(allPassPrevInput#) || Math.abs(allPassPrevInput#) < epsilon) allPassPrevInput# = 0.0;\n\t\t\t\tif (!Number.isFinite(shelfSample#) || Math.abs(shelfSample#) < epsilon) shelfSample# = 0.0;\n\t\t\t\tif (!Number.isFinite(shelfPrevInput#) || Math.abs(shelfPrevInput#) < epsilon) shelfPrevInput# = 0.0;\n\t\t\t\tif (!Number.isFinite(fractionalDelaySample#) || Math.abs(fractionalDelaySample#) < epsilon) fractionalDelaySample# = 0.0;\n\t\t\t\tpickedString#.allPassSample = allPassSample#;\n\t\t\t\tpickedString#.allPassPrevInput = allPassPrevInput#;\n\t\t\t\tpickedString#.shelfSample = shelfSample#;\n\t\t\t\tpickedString#.shelfPrevInput = shelfPrevInput#;\n\t\t\t\tpickedString#.fractionalDelaySample = fractionalDelaySample#;\n\t\t\t\tpickedString#.delayIndex = delayIndex#;\n\t\t\t\tpickedString#.prevDelayLength = delayLength#;\n\t\t\t\t\n\t\t\t\tsynth.sanitizeFilters(filters);\n\t\t\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\n\t\t\t\ttone.initialNoteFilterInput2 = initialFilterInput2;",t=t.replace(/^.*\#.*$/gm,(t=>{const e=[];for(let s=0;s<r;s++)e.push(t.replace(/\#/g,String(s)));return e.join("\n")})),h=new Function("synth","bufferIndex","runLength","tone","instrument",t),X.pickedStringFunctionCache[r]=h}h(t,s,n,i,a)}static effectsSynth(t,s,n,i,a,r,h){const o=m(r.effects)&&0!=r.distortion,l=S(r.effects),c=h.eqFilterCount>0,u=y(r.effects)&&r.pan!=e.panCenter,f=b(r.effects)&&0!=r.chorus,p=M(r.effects)&&0!=r.echoSustain,d=g(r.effects)&&0!=r.reverb;let v=0;o&&(v|=1),v<<=1,l&&(v|=1),v<<=1,c&&(v|=1),v<<=1,u&&(v|=1),v<<=1,f&&(v|=1),v<<=1,p&&(v|=1),v<<=1,d&&(v|=1);let I=X.effectsFunctionCache[v];if(null==I){let t="";const e=f||d||p;t+="\n\t\t\t\tconst tempMonoInstrumentSampleBuffer = synth.tempMonoInstrumentSampleBuffer;\n\t\t\t\t\n\t\t\t\tlet mixVolume = +instrumentState.mixVolumeStart;\n\t\t\t\tconst mixVolumeDelta = +instrumentState.mixVolumeDelta;",e&&(t+="\n\t\t\t\t\n\t\t\t\tlet delayInputMult = +instrumentState.delayInputMultStart;\n\t\t\t\tconst delayInputMultDelta = +instrumentState.delayInputMultDelta;"),o&&(t+="\n\t\t\t\t\n\t\t\t\tconst distortionBaseVolume = +beepbox.Config.distortionBaseVolume;\n\t\t\t\tconst distortionStart = +Math.pow(1.0 - 0.895 * (Math.pow(20.0, instrumentState.distortionStart) - 1.0) / 19.0, 2.0)\n\t\t\t\tconst distortionEnd   = +Math.pow(1.0 - 0.895 * (Math.pow(20.0, instrumentState.distortionEnd  ) - 1.0) / 19.0, 2.0)\n\t\t\t\tlet distortion = distortionStart;\n\t\t\t\tconst distortionDelta = (distortionEnd - distortionStart) / runLength;\n\t\t\t\tconst distortionDriveStart = (1.0 + 2.0 * instrumentState.distortionStart) / distortionBaseVolume;\n\t\t\t\tconst distortionDriveEnd   = (1.0 + 2.0 * instrumentState.distortionEnd)   / distortionBaseVolume;\n\t\t\t\tlet distortionDrive = distortionDriveStart;\n\t\t\t\tconst distortionDriveDelta = (distortionDriveEnd - distortionDriveStart) / runLength;\n\t\t\t\tconst distortionFractionalResolution = 4.0;\n\t\t\t\tconst distortionOversampleCompensation = distortionBaseVolume / distortionFractionalResolution;\n\t\t\t\tconst distortionFractionalDelay1 = 1.0 / distortionFractionalResolution;\n\t\t\t\tconst distortionFractionalDelay2 = 2.0 / distortionFractionalResolution;\n\t\t\t\tconst distortionFractionalDelay3 = 3.0 / distortionFractionalResolution;\n\t\t\t\tconst distortionFractionalDelayG1 = (1.0 - distortionFractionalDelay1) / (1.0 + distortionFractionalDelay1); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\n\t\t\t\tconst distortionFractionalDelayG2 = (1.0 - distortionFractionalDelay2) / (1.0 + distortionFractionalDelay2); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\n\t\t\t\tconst distortionFractionalDelayG3 = (1.0 - distortionFractionalDelay3) / (1.0 + distortionFractionalDelay3); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\n\t\t\t\tconst distortionNextOutputWeight1 = Math.cos(Math.PI * distortionFractionalDelay1) * 0.5 + 0.5;\n\t\t\t\tconst distortionNextOutputWeight2 = Math.cos(Math.PI * distortionFractionalDelay2) * 0.5 + 0.5;\n\t\t\t\tconst distortionNextOutputWeight3 = Math.cos(Math.PI * distortionFractionalDelay3) * 0.5 + 0.5;\n\t\t\t\tconst distortionPrevOutputWeight1 = 1.0 - distortionNextOutputWeight1;\n\t\t\t\tconst distortionPrevOutputWeight2 = 1.0 - distortionNextOutputWeight2;\n\t\t\t\tconst distortionPrevOutputWeight3 = 1.0 - distortionNextOutputWeight3;\n\t\t\t\t\n\t\t\t\tlet distortionFractionalInput1 = +instrumentState.distortionFractionalInput1;\n\t\t\t\tlet distortionFractionalInput2 = +instrumentState.distortionFractionalInput2;\n\t\t\t\tlet distortionFractionalInput3 = +instrumentState.distortionFractionalInput3;\n\t\t\t\tlet distortionPrevInput = +instrumentState.distortionPrevInput;\n\t\t\t\tlet distortionNextOutput = +instrumentState.distortionNextOutput;"),l&&(t+="\n\t\t\t\t\n\t\t\t\tlet bitcrusherPrevInput = +instrumentState.bitcrusherPrevInput;\n\t\t\t\tlet bitcrusherCurrentOutput = +instrumentState.bitcrusherCurrentOutput;\n\t\t\t\tlet bitcrusherPhase = +instrumentState.bitcrusherPhase;\n\t\t\t\tlet bitcrusherPhaseDelta = +instrumentState.bitcrusherPhaseDelta;\n\t\t\t\tconst bitcrusherPhaseDeltaScale = +instrumentState.bitcrusherPhaseDeltaScale;\n\t\t\t\tlet bitcrusherScale = +instrumentState.bitcrusherScale;\n\t\t\t\tconst bitcrusherScaleScale = +instrumentState.bitcrusherScaleScale;\n\t\t\t\tlet bitcrusherFoldLevel = +instrumentState.bitcrusherFoldLevel;\n\t\t\t\tconst bitcrusherFoldLevelScale = +instrumentState.bitcrusherFoldLevelScale;"),c&&(t+="\n\t\t\t\t\n\t\t\t\tlet filters = instrumentState.eqFilters;\n\t\t\t\tconst filterCount = instrumentState.eqFilterCount|0;\n\t\t\t\tlet initialFilterInput1 = +instrumentState.initialEqFilterInput1;\n\t\t\t\tlet initialFilterInput2 = +instrumentState.initialEqFilterInput2;\n\t\t\t\tconst applyFilters = beepbox.Synth.applyFilters;"),t+="\n\t\t\t\t\n\t\t\t\tlet eqFilterVolume = +instrumentState.eqFilterVolumeStart;\n\t\t\t\tconst eqFilterVolumeDelta = +instrumentState.eqFilterVolumeDelta;",u&&(t+="\n\t\t\t\t\n\t\t\t\tconst panningMask = synth.panningDelayBufferMask >>> 0;\n\t\t\t\tconst panningDelayLine = instrumentState.panningDelayLine;\n\t\t\t\tlet panningDelayPos = instrumentState.panningDelayPos & panningMask;\n\t\t\t\tlet   panningVolumeL      = +instrumentState.panningVolumeStartL;\n\t\t\t\tlet   panningVolumeR      = +instrumentState.panningVolumeStartR;\n\t\t\t\tconst panningVolumeDeltaL = +instrumentState.panningVolumeDeltaL;\n\t\t\t\tconst panningVolumeDeltaR = +instrumentState.panningVolumeDeltaR;\n\t\t\t\tlet   panningOffsetL      = panningDelayPos - instrumentState.panningOffsetStartL + synth.panningDelayBufferSize;\n\t\t\t\tlet   panningOffsetR      = panningDelayPos - instrumentState.panningOffsetStartR + synth.panningDelayBufferSize;\n\t\t\t\tconst panningOffsetDeltaL = 1.0 - instrumentState.panningOffsetDeltaL;\n\t\t\t\tconst panningOffsetDeltaR = 1.0 - instrumentState.panningOffsetDeltaR;"),f&&(t+="\n\t\t\t\t\n\t\t\t\tconst chorusMask = synth.chorusDelayBufferMask >>> 0;\n\t\t\t\tconst chorusDelayLineL = instrumentState.chorusDelayLineL;\n\t\t\t\tconst chorusDelayLineR = instrumentState.chorusDelayLineR;\n\t\t\t\tinstrumentState.chorusDelayLineDirty = true;\n\t\t\t\tlet chorusDelayPos = instrumentState.chorusDelayPos & chorusMask;\n\t\t\t\t\n\t\t\t\tconst chorusStart = +instrumentState.chorusStart;\n\t\t\t\tconst chorusEnd   = +instrumentState.chorusEnd;\n\t\t\t\tlet chorusVoiceMult = chorusStart;\n\t\t\t\tconst chorusVoiceMultDelta = (chorusEnd - chorusStart) / runLength;\n\t\t\t\tlet chorusCombinedMult = 1.0 / Math.sqrt(3.0 * chorusStart * chorusStart + 1.0);\n\t\t\t\tconst chorusCombinedMultEnd = 1.0 / Math.sqrt(3.0 * chorusEnd * chorusEnd + 1.0);\n\t\t\t\tconst chorusCombinedMultDelta = (chorusCombinedMultEnd - chorusCombinedMult) / runLength;\n\t\t\t\t\n\t\t\t\tconst chorusDuration = +beepbox.Config.chorusPeriodSeconds;\n\t\t\t\tconst chorusAngle = Math.PI * 2.0 / (chorusDuration * synth.samplesPerSecond);\n\t\t\t\tconst chorusRange = synth.samplesPerSecond * beepbox.Config.chorusDelayRange;\n\t\t\t\tconst chorusOffset0 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[0][0] * chorusRange;\n\t\t\t\tconst chorusOffset1 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[0][1] * chorusRange;\n\t\t\t\tconst chorusOffset2 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[0][2] * chorusRange;\n\t\t\t\tconst chorusOffset3 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[1][0] * chorusRange;\n\t\t\t\tconst chorusOffset4 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[1][1] * chorusRange;\n\t\t\t\tconst chorusOffset5 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[1][2] * chorusRange;\n\t\t\t\tlet chorusPhase = instrumentState.chorusPhase % (Math.PI * 2.0);\n\t\t\t\tlet chorusTap0Index = chorusDelayPos + chorusOffset0 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][0]);\n\t\t\t\tlet chorusTap1Index = chorusDelayPos + chorusOffset1 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][1]);\n\t\t\t\tlet chorusTap2Index = chorusDelayPos + chorusOffset2 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][2]);\n\t\t\t\tlet chorusTap3Index = chorusDelayPos + chorusOffset3 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][0]);\n\t\t\t\tlet chorusTap4Index = chorusDelayPos + chorusOffset4 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][1]);\n\t\t\t\tlet chorusTap5Index = chorusDelayPos + chorusOffset5 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][2]);\n\t\t\t\tchorusPhase += chorusAngle * runLength;\n\t\t\t\tconst chorusTap0End = chorusDelayPos + chorusOffset0 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][0]) + runLength;\n\t\t\t\tconst chorusTap1End = chorusDelayPos + chorusOffset1 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][1]) + runLength;\n\t\t\t\tconst chorusTap2End = chorusDelayPos + chorusOffset2 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][2]) + runLength;\n\t\t\t\tconst chorusTap3End = chorusDelayPos + chorusOffset3 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][0]) + runLength;\n\t\t\t\tconst chorusTap4End = chorusDelayPos + chorusOffset4 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][1]) + runLength;\n\t\t\t\tconst chorusTap5End = chorusDelayPos + chorusOffset5 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][2]) + runLength;\n\t\t\t\tconst chorusTap0Delta = (chorusTap0End - chorusTap0Index) / runLength;\n\t\t\t\tconst chorusTap1Delta = (chorusTap1End - chorusTap1Index) / runLength;\n\t\t\t\tconst chorusTap2Delta = (chorusTap2End - chorusTap2Index) / runLength;\n\t\t\t\tconst chorusTap3Delta = (chorusTap3End - chorusTap3Index) / runLength;\n\t\t\t\tconst chorusTap4Delta = (chorusTap4End - chorusTap4Index) / runLength;\n\t\t\t\tconst chorusTap5Delta = (chorusTap5End - chorusTap5Index) / runLength;"),p&&(t+="\n\t\t\t\t\n\t\t\t\tlet echoMult = +instrumentState.echoMultStart;\n\t\t\t\tconst echoMultDelta = +instrumentState.echoMultDelta;\n\t\t\t\t\n\t\t\t\tconst echoDelayLineL = instrumentState.echoDelayLineL;\n\t\t\t\tconst echoDelayLineR = instrumentState.echoDelayLineR;\n\t\t\t\tconst echoMask = (echoDelayLineL.length - 1) >>> 0;\n\t\t\t\tinstrumentState.echoDelayLineDirty = true;\n\t\t\t\t\n\t\t\t\tlet echoDelayPos = instrumentState.echoDelayPos & echoMask;\n\t\t\t\tconst echoDelayOffsetStart = (echoDelayLineL.length - instrumentState.echoDelayOffsetStart) & echoMask;\n\t\t\t\tconst echoDelayOffsetEnd   = (echoDelayLineL.length - instrumentState.echoDelayOffsetEnd) & echoMask;\n\t\t\t\tlet echoDelayOffsetRatio = +instrumentState.echoDelayOffsetRatio;\n\t\t\t\tconst echoDelayOffsetRatioDelta = +instrumentState.echoDelayOffsetRatioDelta;\n\t\t\t\t\n\t\t\t\tconst echoShelfA1 = +instrumentState.echoShelfA1;\n\t\t\t\tconst echoShelfB0 = +instrumentState.echoShelfB0;\n\t\t\t\tconst echoShelfB1 = +instrumentState.echoShelfB1;\n\t\t\t\tlet echoShelfSampleL = +instrumentState.echoShelfSampleL;\n\t\t\t\tlet echoShelfSampleR = +instrumentState.echoShelfSampleR;\n\t\t\t\tlet echoShelfPrevInputL = +instrumentState.echoShelfPrevInputL;\n\t\t\t\tlet echoShelfPrevInputR = +instrumentState.echoShelfPrevInputR;"),d&&(t+="\n\t\t\t\t\n\t\t\t\tconst reverbMask = beepbox.Config.reverbDelayBufferMask >>> 0; //TODO: Dynamic reverb buffer size.\n\t\t\t\tconst reverbDelayLine = instrumentState.reverbDelayLine;\n\t\t\t\tinstrumentState.reverbDelayLineDirty = true;\n\t\t\t\tlet reverbDelayPos = instrumentState.reverbDelayPos & reverbMask;\n\t\t\t\t\n\t\t\t\tlet reverb = +instrumentState.reverbMultStart;\n\t\t\t\tconst reverbDelta = +instrumentState.reverbMultDelta;\n\t\t\t\t\n\t\t\t\tconst reverbShelfA1 = +instrumentState.reverbShelfA1;\n\t\t\t\tconst reverbShelfB0 = +instrumentState.reverbShelfB0;\n\t\t\t\tconst reverbShelfB1 = +instrumentState.reverbShelfB1;\n\t\t\t\tlet reverbShelfSample0 = +instrumentState.reverbShelfSample0;\n\t\t\t\tlet reverbShelfSample1 = +instrumentState.reverbShelfSample1;\n\t\t\t\tlet reverbShelfSample2 = +instrumentState.reverbShelfSample2;\n\t\t\t\tlet reverbShelfSample3 = +instrumentState.reverbShelfSample3;\n\t\t\t\tlet reverbShelfPrevInput0 = +instrumentState.reverbShelfPrevInput0;\n\t\t\t\tlet reverbShelfPrevInput1 = +instrumentState.reverbShelfPrevInput1;\n\t\t\t\tlet reverbShelfPrevInput2 = +instrumentState.reverbShelfPrevInput2;\n\t\t\t\tlet reverbShelfPrevInput3 = +instrumentState.reverbShelfPrevInput3;"),t+="\n\t\t\t\t\n\t\t\t\tconst stopIndex = bufferIndex + runLength;\n\t\t\t\tfor (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\n\t\t\t\t\tlet sample = tempMonoInstrumentSampleBuffer[sampleIndex];\n\t\t\t\t\ttempMonoInstrumentSampleBuffer[sampleIndex] = 0.0;",o&&(t+="\n\t\t\t\t\t\n\t\t\t\t\tconst distortionReverse = 1.0 - distortion;\n\t\t\t\t\tconst distortionNextInput = sample * distortionDrive;\n\t\t\t\t\tsample = distortionNextOutput;\n\t\t\t\t\tdistortionNextOutput = distortionNextInput / (distortionReverse * Math.abs(distortionNextInput) + distortion);\n\t\t\t\t\tdistortionFractionalInput1 = distortionFractionalDelayG1 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG1 * distortionFractionalInput1;\n\t\t\t\t\tdistortionFractionalInput2 = distortionFractionalDelayG2 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG2 * distortionFractionalInput2;\n\t\t\t\t\tdistortionFractionalInput3 = distortionFractionalDelayG3 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG3 * distortionFractionalInput3;\n\t\t\t\t\tconst distortionOutput1 = distortionFractionalInput1 / (distortionReverse * Math.abs(distortionFractionalInput1) + distortion);\n\t\t\t\t\tconst distortionOutput2 = distortionFractionalInput2 / (distortionReverse * Math.abs(distortionFractionalInput2) + distortion);\n\t\t\t\t\tconst distortionOutput3 = distortionFractionalInput3 / (distortionReverse * Math.abs(distortionFractionalInput3) + distortion);\n\t\t\t\t\tdistortionNextOutput += distortionOutput1 * distortionNextOutputWeight1 + distortionOutput2 * distortionNextOutputWeight2 + distortionOutput3 * distortionNextOutputWeight3;\n\t\t\t\t\tsample += distortionOutput1 * distortionPrevOutputWeight1 + distortionOutput2 * distortionPrevOutputWeight2 + distortionOutput3 * distortionPrevOutputWeight3;\n\t\t\t\t\tsample *= distortionOversampleCompensation;\n\t\t\t\t\tdistortionPrevInput = distortionNextInput;\n\t\t\t\t\tdistortion += distortionDelta;\n\t\t\t\t\tdistortionDrive += distortionDriveDelta;"),l&&(t+="\n\t\t\t\t\t\n\t\t\t\t\tbitcrusherPhase += bitcrusherPhaseDelta;\n\t\t\t\t\tif (bitcrusherPhase < 1.0) {\n\t\t\t\t\t\tbitcrusherPrevInput = sample;\n\t\t\t\t\t\tsample = bitcrusherCurrentOutput;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbitcrusherPhase = bitcrusherPhase % 1.0;\n\t\t\t\t\t\tconst ratio = bitcrusherPhase / bitcrusherPhaseDelta;\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst lerpedInput = sample + (bitcrusherPrevInput - sample) * ratio;\n\t\t\t\t\t\tbitcrusherPrevInput = sample;\n\t\t\t\t\t\t\n\t\t\t\t\t\tconst bitcrusherWrapLevel = bitcrusherFoldLevel * 4.0;\n\t\t\t\t\t\tconst wrappedSample = (((lerpedInput + bitcrusherFoldLevel) % bitcrusherWrapLevel) + bitcrusherWrapLevel) % bitcrusherWrapLevel;\n\t\t\t\t\t\tconst foldedSample = bitcrusherFoldLevel - Math.abs(bitcrusherFoldLevel * 2.0 - wrappedSample);\n\t\t\t\t\t\tconst scaledSample = foldedSample / bitcrusherScale;\n\t\t\t\t\t\tconst oldValue = bitcrusherCurrentOutput;\n\t\t\t\t\t\tconst newValue = (((scaledSample > 0 ? scaledSample + 1 : scaledSample)|0)-.5) * bitcrusherScale;\n\t\t\t\t\t\t\n\t\t\t\t\t\tsample = oldValue + (newValue - oldValue) * ratio;\n\t\t\t\t\t\tbitcrusherCurrentOutput = newValue;\n\t\t\t\t\t}\n\t\t\t\t\tbitcrusherPhaseDelta *= bitcrusherPhaseDeltaScale;\n\t\t\t\t\tbitcrusherScale *= bitcrusherScaleScale;\n\t\t\t\t\tbitcrusherFoldLevel *= bitcrusherFoldLevelScale;"),c&&(t+="\n\t\t\t\t\t\n\t\t\t\t\tconst inputSample = sample;\n\t\t\t\t\tsample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\n\t\t\t\t\tinitialFilterInput2 = initialFilterInput1;\n\t\t\t\t\tinitialFilterInput1 = inputSample;"),t+="\n\t\t\t\t\t\n\t\t\t\t\tsample *= eqFilterVolume;\n\t\t\t\t\teqFilterVolume += eqFilterVolumeDelta;",t+=u?"\n\t\t\t\t\t\n\t\t\t\t\tpanningDelayLine[panningDelayPos] = sample;\n\t\t\t\t\tconst panningRatioL  = panningOffsetL % 1;\n\t\t\t\t\tconst panningRatioR  = panningOffsetR % 1;\n\t\t\t\t\tconst panningTapLA   = panningDelayLine[(panningOffsetL) & panningMask];\n\t\t\t\t\tconst panningTapLB   = panningDelayLine[(panningOffsetL + 1) & panningMask];\n\t\t\t\t\tconst panningTapRA   = panningDelayLine[(panningOffsetR) & panningMask];\n\t\t\t\t\tconst panningTapRB   = panningDelayLine[(panningOffsetR + 1) & panningMask];\n\t\t\t\t\tconst panningTapL    = panningTapLA + (panningTapLB - panningTapLA) * panningRatioL;\n\t\t\t\t\tconst panningTapR    = panningTapRA + (panningTapRB - panningTapRA) * panningRatioR;\n\t\t\t\t\tlet sampleL = panningTapL * panningVolumeL;\n\t\t\t\t\tlet sampleR = panningTapR * panningVolumeR;\n\t\t\t\t\tpanningDelayPos = (panningDelayPos + 1) & panningMask;\n\t\t\t\t\tpanningVolumeL += panningVolumeDeltaL;\n\t\t\t\t\tpanningVolumeR += panningVolumeDeltaR;\n\t\t\t\t\tpanningOffsetL += panningOffsetDeltaL;\n\t\t\t\t\tpanningOffsetR += panningOffsetDeltaR;":"\n\t\t\t\t\t\n\t\t\t\t\tlet sampleL = sample;\n\t\t\t\t\tlet sampleR = sample;",f&&(t+="\n\t\t\t\t\t\n\t\t\t\t\tconst chorusTap0Ratio = chorusTap0Index % 1;\n\t\t\t\t\tconst chorusTap1Ratio = chorusTap1Index % 1;\n\t\t\t\t\tconst chorusTap2Ratio = chorusTap2Index % 1;\n\t\t\t\t\tconst chorusTap3Ratio = chorusTap3Index % 1;\n\t\t\t\t\tconst chorusTap4Ratio = chorusTap4Index % 1;\n\t\t\t\t\tconst chorusTap5Ratio = chorusTap5Index % 1;\n\t\t\t\t\tconst chorusTap0A = chorusDelayLineL[(chorusTap0Index) & chorusMask];\n\t\t\t\t\tconst chorusTap0B = chorusDelayLineL[(chorusTap0Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap1A = chorusDelayLineL[(chorusTap1Index) & chorusMask];\n\t\t\t\t\tconst chorusTap1B = chorusDelayLineL[(chorusTap1Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap2A = chorusDelayLineL[(chorusTap2Index) & chorusMask];\n\t\t\t\t\tconst chorusTap2B = chorusDelayLineL[(chorusTap2Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap3A = chorusDelayLineR[(chorusTap3Index) & chorusMask];\n\t\t\t\t\tconst chorusTap3B = chorusDelayLineR[(chorusTap3Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap4A = chorusDelayLineR[(chorusTap4Index) & chorusMask];\n\t\t\t\t\tconst chorusTap4B = chorusDelayLineR[(chorusTap4Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap5A = chorusDelayLineR[(chorusTap5Index) & chorusMask];\n\t\t\t\t\tconst chorusTap5B = chorusDelayLineR[(chorusTap5Index + 1) & chorusMask];\n\t\t\t\t\tconst chorusTap0 = chorusTap0A + (chorusTap0B - chorusTap0A) * chorusTap0Ratio;\n\t\t\t\t\tconst chorusTap1 = chorusTap1A + (chorusTap1B - chorusTap1A) * chorusTap1Ratio;\n\t\t\t\t\tconst chorusTap2 = chorusTap2A + (chorusTap2B - chorusTap2A) * chorusTap2Ratio;\n\t\t\t\t\tconst chorusTap3 = chorusTap3A + (chorusTap3B - chorusTap3A) * chorusTap3Ratio;\n\t\t\t\t\tconst chorusTap4 = chorusTap4A + (chorusTap4B - chorusTap4A) * chorusTap4Ratio;\n\t\t\t\t\tconst chorusTap5 = chorusTap5A + (chorusTap5B - chorusTap5A) * chorusTap5Ratio;\n\t\t\t\t\tchorusDelayLineL[chorusDelayPos] = sampleL * delayInputMult;\n\t\t\t\t\tchorusDelayLineR[chorusDelayPos] = sampleR * delayInputMult;\n\t\t\t\t\tsampleL = chorusCombinedMult * (sampleL + chorusVoiceMult * (chorusTap1 - chorusTap0 - chorusTap2));\n\t\t\t\t\tsampleR = chorusCombinedMult * (sampleR + chorusVoiceMult * (chorusTap4 - chorusTap3 - chorusTap5));\n\t\t\t\t\tchorusDelayPos = (chorusDelayPos + 1) & chorusMask;\n\t\t\t\t\tchorusTap0Index += chorusTap0Delta;\n\t\t\t\t\tchorusTap1Index += chorusTap1Delta;\n\t\t\t\t\tchorusTap2Index += chorusTap2Delta;\n\t\t\t\t\tchorusTap3Index += chorusTap3Delta;\n\t\t\t\t\tchorusTap4Index += chorusTap4Delta;\n\t\t\t\t\tchorusTap5Index += chorusTap5Delta;\n\t\t\t\t\tchorusVoiceMult += chorusVoiceMultDelta;\n\t\t\t\t\tchorusCombinedMult += chorusCombinedMultDelta;"),p&&(t+="\n\t\t\t\t\t\n\t\t\t\t\tconst echoTapStartIndex = (echoDelayPos + echoDelayOffsetStart) & echoMask;\n\t\t\t\t\tconst echoTapEndIndex   = (echoDelayPos + echoDelayOffsetEnd  ) & echoMask;\n\t\t\t\t\tconst echoTapStartL = echoDelayLineL[echoTapStartIndex];\n\t\t\t\t\tconst echoTapEndL   = echoDelayLineL[echoTapEndIndex];\n\t\t\t\t\tconst echoTapStartR = echoDelayLineR[echoTapStartIndex];\n\t\t\t\t\tconst echoTapEndR   = echoDelayLineR[echoTapEndIndex];\n\t\t\t\t\tconst echoTapL = (echoTapStartL + (echoTapEndL - echoTapStartL) * echoDelayOffsetRatio) * echoMult;\n\t\t\t\t\tconst echoTapR = (echoTapStartR + (echoTapEndR - echoTapStartR) * echoDelayOffsetRatio) * echoMult;\n\t\t\t\t\t\n\t\t\t\t\techoShelfSampleL = echoShelfB0 * echoTapL + echoShelfB1 * echoShelfPrevInputL - echoShelfA1 * echoShelfSampleL;\n\t\t\t\t\techoShelfSampleR = echoShelfB0 * echoTapR + echoShelfB1 * echoShelfPrevInputR - echoShelfA1 * echoShelfSampleR;\n\t\t\t\t\techoShelfPrevInputL = echoTapL;\n\t\t\t\t\techoShelfPrevInputR = echoTapR;\n\t\t\t\t\tsampleL += echoShelfSampleL;\n\t\t\t\t\tsampleR += echoShelfSampleR;\n\t\t\t\t\t\n\t\t\t\t\techoDelayLineL[echoDelayPos] = sampleL * delayInputMult;\n\t\t\t\t\techoDelayLineR[echoDelayPos] = sampleR * delayInputMult;\n\t\t\t\t\techoDelayPos = (echoDelayPos + 1) & echoMask;\n\t\t\t\t\techoDelayOffsetRatio += echoDelayOffsetRatioDelta;\n\t\t\t\t\techoMult += echoMultDelta;"),d&&(t+="\n\t\t\t\t\t\n\t\t\t\t\t// Reverb, implemented using a feedback delay network with a Hadamard matrix and lowpass filters.\n\t\t\t\t\t// good ratios:    0.555235 + 0.618033 + 0.818 +   1.0 = 2.991268\n\t\t\t\t\t// Delay lengths:  3041     + 3385     + 4481  +  5477 = 16384 = 2^14\n\t\t\t\t\t// Buffer offsets: 3041    -> 6426   -> 10907 -> 16384\n\t\t\t\t\tconst reverbDelayPos1 = (reverbDelayPos +  3041) & reverbMask;\n\t\t\t\t\tconst reverbDelayPos2 = (reverbDelayPos +  6426) & reverbMask;\n\t\t\t\t\tconst reverbDelayPos3 = (reverbDelayPos + 10907) & reverbMask;\n\t\t\t\t\tconst reverbSample0 = (reverbDelayLine[reverbDelayPos]);\n\t\t\t\t\tconst reverbSample1 = reverbDelayLine[reverbDelayPos1];\n\t\t\t\t\tconst reverbSample2 = reverbDelayLine[reverbDelayPos2];\n\t\t\t\t\tconst reverbSample3 = reverbDelayLine[reverbDelayPos3];\n\t\t\t\t\tconst reverbTemp0 = -(reverbSample0 + sampleL) + reverbSample1;\n\t\t\t\t\tconst reverbTemp1 = -(reverbSample0 + sampleR) - reverbSample1;\n\t\t\t\t\tconst reverbTemp2 = -reverbSample2 + reverbSample3;\n\t\t\t\t\tconst reverbTemp3 = -reverbSample2 - reverbSample3;\n\t\t\t\t\tconst reverbShelfInput0 = (reverbTemp0 + reverbTemp2) * reverb;\n\t\t\t\t\tconst reverbShelfInput1 = (reverbTemp1 + reverbTemp3) * reverb;\n\t\t\t\t\tconst reverbShelfInput2 = (reverbTemp0 - reverbTemp2) * reverb;\n\t\t\t\t\tconst reverbShelfInput3 = (reverbTemp1 - reverbTemp3) * reverb;\n\t\t\t\t\treverbShelfSample0 = reverbShelfB0 * reverbShelfInput0 + reverbShelfB1 * reverbShelfPrevInput0 - reverbShelfA1 * reverbShelfSample0;\n\t\t\t\t\treverbShelfSample1 = reverbShelfB0 * reverbShelfInput1 + reverbShelfB1 * reverbShelfPrevInput1 - reverbShelfA1 * reverbShelfSample1;\n\t\t\t\t\treverbShelfSample2 = reverbShelfB0 * reverbShelfInput2 + reverbShelfB1 * reverbShelfPrevInput2 - reverbShelfA1 * reverbShelfSample2;\n\t\t\t\t\treverbShelfSample3 = reverbShelfB0 * reverbShelfInput3 + reverbShelfB1 * reverbShelfPrevInput3 - reverbShelfA1 * reverbShelfSample3;\n\t\t\t\t\treverbShelfPrevInput0 = reverbShelfInput0;\n\t\t\t\t\treverbShelfPrevInput1 = reverbShelfInput1;\n\t\t\t\t\treverbShelfPrevInput2 = reverbShelfInput2;\n\t\t\t\t\treverbShelfPrevInput3 = reverbShelfInput3;\n\t\t\t\t\treverbDelayLine[reverbDelayPos1] = reverbShelfSample0 * delayInputMult;\n\t\t\t\t\treverbDelayLine[reverbDelayPos2] = reverbShelfSample1 * delayInputMult;\n\t\t\t\t\treverbDelayLine[reverbDelayPos3] = reverbShelfSample2 * delayInputMult;\n\t\t\t\t\treverbDelayLine[reverbDelayPos ] = reverbShelfSample3 * delayInputMult;\n\t\t\t\t\treverbDelayPos = (reverbDelayPos + 1) & reverbMask;\n\t\t\t\t\tsampleL += reverbSample1 + reverbSample2 + reverbSample3;\n\t\t\t\t\tsampleR += reverbSample0 + reverbSample2 - reverbSample3;\n\t\t\t\t\treverb += reverbDelta;"),t+="\n\t\t\t\t\t\n\t\t\t\t\toutputDataL[sampleIndex] += sampleL * mixVolume;\n\t\t\t\t\toutputDataR[sampleIndex] += sampleR * mixVolume;\n\t\t\t\t\tmixVolume += mixVolumeDelta;",e&&(t+="\n\t\t\t\t\t\n\t\t\t\t\tdelayInputMult += delayInputMultDelta;"),t+="\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Avoid persistent denormal or NaN values in the delay buffers and filter history.\n\t\t\t\tconst epsilon = (1.0e-24);",o&&(t+="\n\t\t\t\t\n\t\t\t\tif (!Number.isFinite(distortionFractionalInput1) || Math.abs(distortionFractionalInput1) < epsilon) distortionFractionalInput1 = 0.0;\n\t\t\t\tif (!Number.isFinite(distortionFractionalInput2) || Math.abs(distortionFractionalInput2) < epsilon) distortionFractionalInput2 = 0.0;\n\t\t\t\tif (!Number.isFinite(distortionFractionalInput3) || Math.abs(distortionFractionalInput3) < epsilon) distortionFractionalInput3 = 0.0;\n\t\t\t\tif (!Number.isFinite(distortionPrevInput) || Math.abs(distortionPrevInput) < epsilon) distortionPrevInput = 0.0;\n\t\t\t\tif (!Number.isFinite(distortionNextOutput) || Math.abs(distortionNextOutput) < epsilon) distortionNextOutput = 0.0;\n\t\t\t\t\n\t\t\t\tinstrumentState.distortionFractionalInput1 = distortionFractionalInput1;\n\t\t\t\tinstrumentState.distortionFractionalInput2 = distortionFractionalInput2;\n\t\t\t\tinstrumentState.distortionFractionalInput3 = distortionFractionalInput3;\n\t\t\t\tinstrumentState.distortionPrevInput = distortionPrevInput;\n\t\t\t\tinstrumentState.distortionNextOutput = distortionNextOutput;"),l&&(t+="\n\t\t\t\t\t\n\t\t\t\tif (Math.abs(bitcrusherPrevInput) < epsilon) bitcrusherPrevInput = 0.0;\n\t\t\t\tif (Math.abs(bitcrusherCurrentOutput) < epsilon) bitcrusherCurrentOutput = 0.0;\n\t\t\t\tinstrumentState.bitcrusherPrevInput = bitcrusherPrevInput;\n\t\t\t\tinstrumentState.bitcrusherCurrentOutput = bitcrusherCurrentOutput;\n\t\t\t\tinstrumentState.bitcrusherPhase = bitcrusherPhase;"),c&&(t+="\n\t\t\t\t\t\n\t\t\t\tsynth.sanitizeFilters(filters);\n\t\t\t\t// The filter input here is downstream from another filter so we\n\t\t\t\t// better make sure it's safe too.\n\t\t\t\tif (!(initialFilterInput1 < 100) || !(initialFilterInput2 < 100)) {\n\t\t\t\t\tinitialFilterInput1 = 0.0;\n\t\t\t\t\tinitialFilterInput2 = 0.0;\n\t\t\t\t}\n\t\t\t\tif (Math.abs(initialFilterInput1) < epsilon) initialFilterInput1 = 0.0;\n\t\t\t\tif (Math.abs(initialFilterInput2) < epsilon) initialFilterInput2 = 0.0;\n\t\t\t\tinstrumentState.initialEqFilterInput1 = initialFilterInput1;\n\t\t\t\tinstrumentState.initialEqFilterInput2 = initialFilterInput2;"),u&&(t+="\n\t\t\t\t\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(panningDelayLine, panningDelayPos, panningMask);\n\t\t\t\tinstrumentState.panningDelayPos = panningDelayPos;"),f&&(t+="\n\t\t\t\t\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(chorusDelayLineL, chorusDelayPos, chorusMask);\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(chorusDelayLineR, chorusDelayPos, chorusMask);\n\t\t\t\tinstrumentState.chorusPhase = chorusPhase;\n\t\t\t\tinstrumentState.chorusDelayPos = chorusDelayPos;"),p&&(t+="\n\t\t\t\t\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(echoDelayLineL, echoDelayPos, echoMask);\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(echoDelayLineR, echoDelayPos, echoMask);\n\t\t\t\tinstrumentState.echoDelayPos = echoDelayPos;\n\t\t\t\t\n\t\t\t\tif (!Number.isFinite(echoShelfSampleL) || Math.abs(echoShelfSampleL) < epsilon) echoShelfSampleL = 0.0;\n\t\t\t\tif (!Number.isFinite(echoShelfSampleR) || Math.abs(echoShelfSampleR) < epsilon) echoShelfSampleR = 0.0;\n\t\t\t\tif (!Number.isFinite(echoShelfPrevInputL) || Math.abs(echoShelfPrevInputL) < epsilon) echoShelfPrevInputL = 0.0;\n\t\t\t\tif (!Number.isFinite(echoShelfPrevInputR) || Math.abs(echoShelfPrevInputR) < epsilon) echoShelfPrevInputR = 0.0;\n\t\t\t\tinstrumentState.echoShelfSampleL = echoShelfSampleL;\n\t\t\t\tinstrumentState.echoShelfSampleR = echoShelfSampleR;\n\t\t\t\tinstrumentState.echoShelfPrevInputL = echoShelfPrevInputL;\n\t\t\t\tinstrumentState.echoShelfPrevInputR = echoShelfPrevInputR;"),d&&(t+="\n\t\t\t\t\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos        , reverbMask);\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos +  3041, reverbMask);\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos +  6426, reverbMask);\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos + 10907, reverbMask);\n\t\t\t\tinstrumentState.reverbDelayPos  = reverbDelayPos;\n\t\t\t\t\n\t\t\t\tif (!Number.isFinite(reverbShelfSample0) || Math.abs(reverbShelfSample0) < epsilon) reverbShelfSample0 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfSample1) || Math.abs(reverbShelfSample1) < epsilon) reverbShelfSample1 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfSample2) || Math.abs(reverbShelfSample2) < epsilon) reverbShelfSample2 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfSample3) || Math.abs(reverbShelfSample3) < epsilon) reverbShelfSample3 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput0) || Math.abs(reverbShelfPrevInput0) < epsilon) reverbShelfPrevInput0 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput1) || Math.abs(reverbShelfPrevInput1) < epsilon) reverbShelfPrevInput1 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput2) || Math.abs(reverbShelfPrevInput2) < epsilon) reverbShelfPrevInput2 = 0.0;\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput3) || Math.abs(reverbShelfPrevInput3) < epsilon) reverbShelfPrevInput3 = 0.0;\n\t\t\t\tinstrumentState.reverbShelfSample0 = reverbShelfSample0;\n\t\t\t\tinstrumentState.reverbShelfSample1 = reverbShelfSample1;\n\t\t\t\tinstrumentState.reverbShelfSample2 = reverbShelfSample2;\n\t\t\t\tinstrumentState.reverbShelfSample3 = reverbShelfSample3;\n\t\t\t\tinstrumentState.reverbShelfPrevInput0 = reverbShelfPrevInput0;\n\t\t\t\tinstrumentState.reverbShelfPrevInput1 = reverbShelfPrevInput1;\n\t\t\t\tinstrumentState.reverbShelfPrevInput2 = reverbShelfPrevInput2;\n\t\t\t\tinstrumentState.reverbShelfPrevInput3 = reverbShelfPrevInput3;"),I=new Function("synth","outputDataL","outputDataR","bufferIndex","runLength","instrument","instrumentState",t),X.effectsFunctionCache[v]=I}I(t,s,n,i,a,r,h)}static pulseWidthSynth(t,e,s,n,i){const a=t.tempMonoInstrumentSampleBuffer;let r=n.phaseDeltas[0];const h=+n.phaseDeltaScales[0];let o=+n.expressionStarts[0];const l=+n.expressionDeltas[0];let c=n.phases[0]%1,u=n.pulseWidth;const f=n.pulseWidthDelta,p=n.noteFilters,d=0|n.noteFilterCount;let m=+n.initialNoteFilterInput1,S=+n.initialNoteFilterInput2;const y=X.applyFilters,b=e+s;for(let t=e;t<b;t++){const e=c%1,s=(c+u)%1;let n=s-e;if(e<r)n+=.5*((M=e/r)+M-M*M-1);else if(e>1-r){n+=.5*((M=(e-1)/r)+M+M*M+1)}if(s<r)n-=.5*((M=s/r)+M-M*M-1);else if(s>1-r){var M;n-=.5*((M=(s-1)/r)+M+M*M+1)}const i=n,b=y(i,m,S,d,p);S=m,m=i,c+=r,r*=h,u+=f;const g=b*o;o+=l,a[t]+=g}n.phases[0]=c,t.sanitizeFilters(p),n.initialNoteFilterInput1=m,n.initialNoteFilterInput2=S}static noiseSynth(t,s,n,i,a){const r=t.tempMonoInstrumentSampleBuffer;let h=a.getDrumWave(),o=+i.phaseDeltas[0];const l=+i.phaseDeltaScales[0];let c=+i.expressionStarts[0];const u=+i.expressionDeltas[0];let f=i.phases[0]%1*e.chipNoiseLength;0==i.phases[0]&&(f=Math.random()*e.chipNoiseLength);const p=e.chipNoiseLength-1;let d=+i.sample;const m=i.noteFilters,S=0|i.noteFilterCount;let y=+i.initialNoteFilterInput1,b=+i.initialNoteFilterInput2;const M=X.applyFilters,g=Math.min(1,i.phaseDeltas[0]*e.chipNoises[a.chipNoise].pitchFilterMult),v=s+n;for(let t=s;t<v;t++){d+=(h[f&p]-d)*g;const e=d,s=M(e,y,b,S,m);b=y,y=e,f+=o,o*=l;const n=s*c;c+=u,r[t]+=n}i.phases[0]=f/e.chipNoiseLength,i.sample=d,t.sanitizeFilters(m),i.initialNoteFilterInput1=y,i.initialNoteFilterInput2=b}static spectrumSynth(t,s,n,i,a){const r=t.tempMonoInstrumentSampleBuffer;let h=a.getDrumWave(),o=128*i.phaseDeltas[0];const l=+i.phaseDeltaScales[0];let c=+i.expressionStarts[0];const u=+i.expressionDeltas[0];let f=+i.sample;const p=i.noteFilters,d=0|i.noteFilterCount;let m=+i.initialNoteFilterInput1,S=+i.initialNoteFilterInput2;const y=X.applyFilters;let b=i.phases[0]%1*e.spectrumNoiseLength;0==i.phases[0]&&(b=X.findRandomZeroCrossing(h,e.spectrumNoiseLength)+o);const M=e.spectrumNoiseLength-1,g=Math.min(1,o),v=s+n;for(let t=s;t<v;t++){const e=0|b,s=e&M;let n=h[s];const i=b-e;n+=(h[s+1]-n)*i,f+=(n-f)*g;const a=f,v=y(a,m,S,d,p);S=m,m=a,b+=o,o*=l;const I=v*c;c+=u,r[t]+=I}i.phases[0]=b/e.spectrumNoiseLength,i.sample=f,t.sanitizeFilters(p),i.initialNoteFilterInput1=m,i.initialNoteFilterInput2=S}static drumsetSynth(t,s,n,i,a){const r=t.tempMonoInstrumentSampleBuffer;let h=a.getDrumsetWave(i.drumsetPitch),o=i.phaseDeltas[0]/H.drumsetIndexReferenceDelta(i.drumsetPitch);const l=+i.phaseDeltaScales[0];let c=+i.expressionStarts[0];const u=+i.expressionDeltas[0],f=i.noteFilters,p=0|i.noteFilterCount;let d=+i.initialNoteFilterInput1,m=+i.initialNoteFilterInput2;const S=X.applyFilters;let y=i.phases[0]%1*e.spectrumNoiseLength;0==i.phases[0]&&(y=X.findRandomZeroCrossing(h,e.spectrumNoiseLength)+o);const b=e.spectrumNoiseLength-1,M=s+n;for(let t=s;t<M;t++){const e=0|y,s=e&b;let n=h[s];const i=y-e;n+=(h[s+1]-n)*i;const a=n,M=S(a,d,m,p,f);m=d,d=a,y+=o,o*=l;const g=M*c;c+=u,r[t]+=g}i.phases[0]=y/e.spectrumNoiseLength,t.sanitizeFilters(f),i.initialNoteFilterInput1=d,i.initialNoteFilterInput2=m}static findRandomZeroCrossing(t,e){let s=Math.random()*e;const n=e-1;let i=s&n,a=t[i];for(let r=128;r>0;r--){const r=i+16&n,h=t[r];if(a*h<=0){for(let r=0;r<16;r++){const r=i+1&n,h=t[r];if(a*h<=0){const t=h-a;s=i,Math.abs(t)>1e-8&&(s+=-a/t),s=Math.max(0,s)%e;break}i=r,a=h}break}i=r,a=h}return s}static instrumentVolumeToVolumeMult(t){return t==e.volumeRange-1?0:Math.pow(2,e.volumeLogScale*t)}static volumeMultToInstrumentVolume(t){return t<=0?e.volumeRange-1:Math.min(e.volumeRange-2,Math.log2(t)/e.volumeLogScale)}static noteSizeToVolumeMult(t){return Math.pow(Math.max(0,t)/e.noteSizeMax,1.5)}static volumeMultToNoteSize(t){return Math.pow(Math.max(0,t),1/1.5)*e.noteSizeMax}static fadeInSettingToSeconds(t){return.0125*(.95*t+.05*t*t)}static secondsToFadeInSetting(t){return E(0,e.fadeInRange,Math.round((-.95+Math.sqrt(.9025+.2*t/.0125))/.1))}static fadeOutSettingToTicks(t){return e.fadeOutTicks[t]}static ticksToFadeOutSetting(t){let s=e.fadeOutTicks[0];if(t<=s)return 0;for(let n=1;n<e.fadeOutTicks.length;n++){let i=e.fadeOutTicks[n];if(t<=i)return t<(s+i)/2?n-1:n;s=i}return e.fadeOutTicks.length-1}static detuneToCents(t){return t*(Math.abs(t)+1)/2}static centsToDetune(t){return Math.sign(t)*(Math.sqrt(1+8*Math.abs(t))-1)/2}getSamplesPerTick(){if(null==this.song)return 0;const t=this.song.getBeatsPerMinute()/60,s=e.partsPerBeat*t,n=e.ticksPerPart*s;return this.samplesPerSecond/n}static fittingPowerOfTwo(t){return 1<<32-Math.clz32(Math.ceil(t)-1)}sanitizeFilters(t){let e=!1;for(const s of t){const t=Math.abs(s.output1),n=Math.abs(s.output2);if(!(t<100&&n<100)){e=!0;break}t<T&&(s.output1=0),n<T&&(s.output2=0)}if(e)for(const e of t)e.output1=0,e.output2=0}static sanitizeDelayLine(t,e,s){for(;;){const n=--e&s,i=Math.abs(t[n]);if(Number.isFinite(i)&&(0==i||i>=T))break;t[n]=0}}static applyFilters(t,e,s,n,i){for(let a=0;a<n;a++){const n=i[a],r=n.output1,h=n.output2,o=n.a1,l=n.a2,c=n.b0,u=n.b1,f=n.b2;t=c*t+u*e+f*s-o*r-l*h,n.a1=o+n.a1Delta,n.a2=l+n.a2Delta,n.useMultiplicativeInputCoefficients?(n.b0=c*n.b0Delta,n.b1=u*n.b1Delta,n.b2=f*n.b2Delta):(n.b0=c+n.b0Delta,n.b1=u+n.b1Delta,n.b2=f+n.b2Delta),n.output2=r,n.output1=t,s=h,e=r}return t}}return X.tempFilterStartCoefficients=new F,X.tempFilterEndCoefficients=new F,X.fmSynthFunctionCache={},X.effectsFunctionCache=Array(128).fill(void 0),X.pickedStringFunctionCache=Array(3).fill(void 0),X.fmSourceTemplate=("\n\t\tconst data = synth.tempMonoInstrumentSampleBuffer;\n\t\tconst sineWave = beepbox.Config.sineWave;\n\t\t\n\t\t// I'm adding 1000 to the phase to ensure that it's never negative even when modulated by other waves because negative numbers don't work with the modulus operator very well.\n\t\tlet operator#Phase       = +((tone.phases[#] % 1) + 1000) * beepbox.Config.sineWaveLength;\n\t\tlet operator#PhaseDelta  = +tone.phaseDeltas[#];\n\t\tlet operator#PhaseDeltaScale = +tone.phaseDeltaScales[#];\n\t\tlet operator#OutputMult  = +tone.expressionStarts[#];\n\t\tconst operator#OutputDelta = +tone.expressionDeltas[#];\n\t\tlet operator#Output      = +tone.feedbackOutputs[#];\n\t\tlet feedbackMult         = +tone.feedbackMult;\n\t\tconst feedbackDelta      = +tone.feedbackDelta;\n\t\t\n\t\tconst filters = tone.noteFilters;\n\t\tconst filterCount = tone.noteFilterCount|0;\n\t\tlet initialFilterInput1 = +tone.initialNoteFilterInput1;\n\t\tlet initialFilterInput2 = +tone.initialNoteFilterInput2;\n\t\tconst applyFilters = beepbox.Synth.applyFilters;\n\t\t\n\t\tconst stopIndex = bufferIndex + runLength;\n\t\tfor (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\n\t\t\t// INSERT OPERATOR COMPUTATION HERE\n\t\t\tconst fmOutput = (/*operator#Scaled*/); // CARRIER OUTPUTS\n\t\t\t\n\t\t\tconst inputSample = fmOutput;\n\t\t\tconst sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\n\t\t\tinitialFilterInput2 = initialFilterInput1;\n\t\t\tinitialFilterInput1 = inputSample;\n\t\t\t\n\t\t\tfeedbackMult += feedbackDelta;\n\t\t\toperator#OutputMult += operator#OutputDelta;\n\t\t\toperator#Phase += operator#PhaseDelta;\n\t\t\toperator#PhaseDelta *= operator#PhaseDeltaScale;\n\t\t\t\n\t\t\tdata[sampleIndex] += sample;\n\t\t}\n\t\t\n\t\ttone.phases[#] = operator#Phase / "+e.sineWaveLength+";\n\t\ttone.feedbackOutputs[#] = operator#Output;\n\t\t\n\t\tsynth.sanitizeFilters(filters);\n\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\n\t\ttone.initialNoteFilterInput2 = initialFilterInput2;\n\t").split("\n"),X.operatorSourceTemplate=("\n\t\t\tconst operator#PhaseMix = operator#Phase/* + operator@Scaled*/;\n\t\t\tconst operator#PhaseInt = operator#PhaseMix|0;\n\t\t\tconst operator#Index    = operator#PhaseInt & "+e.sineWaveMask+";\n\t\t\tconst operator#Sample   = sineWave[operator#Index];\n\t\t\toperator#Output         = operator#Sample + (sineWave[operator#Index + 1] - operator#Sample) * (operator#PhaseMix - operator#PhaseInt);\n\t\t\tconst operator#Scaled   = operator#OutputMult * operator#Output;\n\t").split("\n"),t.Channel=j,t.Config=e,t.EnvelopeSettings=U,t.FilterControlPoint=q,t.FilterSettings=G,t.HarmonicsWave=V,t.Instrument=H,t.Note=A,t.Operator=z,t.Pattern=N,t.Song=K,t.SpectrumWave=W,t.Synth=X,t.clamp=E,t.makeNotePin=C,Object.defineProperty(t,"N",{value:!0}),t}({});
//# sourceMappingURL=beepbox_synth.min.js.map